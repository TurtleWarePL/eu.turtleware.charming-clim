#+title: Charming CLIM tutorial part 2 – Rethinking I/O
#+author: Daniel 'jackdaniel' Kochmański
#+email: daniel@turtleware.eu
#+hugo_base_dir: ~/hugo/

This is the second part of a tutorial about building a McCLIM backend
for the terminal starting from zero. After reading [[https://turtleware.eu/posts/Controlling-the-terminal.html][the first issue]] we
should have a good grasp of how to control and read input from the
terminal. It is time to refine things for efficiency and ease of use.
If you didn't follow the last part, here is the archive with the
[[https://turtleware.eu/static/misc/01-controlling-the-terminal.tar.gz][source code]] which will serve as a starter for this post. If you like
this kind of work, you can [[https://www.patreon.com/jackdaniel_kochmanski][toss a coin to your Lisper]] :-).

Right now our I/O is synchronous with the terminal. When we call ~out~
or ~ctl~, the characters are sent to it immedietely, and we read the
input with ~read-input~ until the stream is empty. The model
introduced in the previous post is certainly simple, but simple models
tend to be hard to use efficiently . We'll settle on _easy_ instead.

* Extending examples

Let's construct a few examples which will help us to identify some
problems. First move functions ~start-display~, ~show-screen~ and
~user-action~ to a separate file ~examples.lisp~ (don't forget to add
this file to the system definition).

First we'll rework slightly our abstraction. First of all we'll
introduce a frame-manager class which will be responsible for
multiplexing input and output on the screen. It has two slots:

- frames :: a list of managed windows
- active :: the active window

For a time being when there is an active frame, only this frame is
rendered. Otherwise all frames are rendered.

All events will be passed to the function ~handle-event~. We'll bind
few keys initially: C-q will exit the application and C-r will remove
all frames and clear the screen.

#+BEGIN_SRC lisp
  (defclass frame-manager ()
    ((frames :initarg :frames :accessor frames :documentation "All frames.")
     (active :initarg :active :accessor active :documentation "Active frame."))
    (:default-initargs :frames nil :active nil))

  (defun handle-event (fm event)
    (flet ((reset ()
             (setf (frames fm) nil
                   (active fm) nil)
             (clear-console)))
      (cond ((keyp event #\Q :c)
             (cl-user::quit))
            ((keyp event #\R :c)
             (reset)))))

  (defun display-screen (fm)
    (alexandria:if-let ((frame (active fm)))
      (render-frame frame)
      (dolist (frame (frames fm))
        (render-frame frame))))

  (defun render-frame (huh?)
    (declare (ignore huh?))
    (error "niy!"))
#+END_SRC

Now let's refactor the function ~start-display~. It will a modeline at
the top and display the terminal dimensions and the frame rate.
Moreover it will create a frame manager and will be responsible for
calling previously defined functions. When we start the application,
we'll see a heart warming message "We are that good!", meaning that we
are too fast to measure the FPS.

#+BEGIN_SRC lisp
  (defun start-display ()
    (swank:create-server)
    (with-console (:ios *terminal-io*)
      (clear-console)
      (loop with rows = (rows *console*)
            with cols = (cols *console*)
            with fm = (make-instance 'frame-manager)
            do (when *console-dirty-p*
                 (update-console-dimensions)
                 (setf rows (rows *console*)
                       cols (cols *console*)))
            do (loop for ch = (read-input)
                     until (null ch)
                     do (handle-event fm ch))
            do (let (start stop delta)
                 (setf start (get-internal-real-time))
                 (display-screen fm)
                 (setf stop (get-internal-real-time))
                 (setf delta (/ (- stop start)
                                internal-time-units-per-second))
                 (ctl (:fgc #x22 #x22 #x22)
                      (:bgc #xbb #xbb #xbb))
                 (let* ((status (format nil "Rows ~3d, Cols ~3d, FPS ~8,2f"
                                        (1- rows) cols (if (zerop delta)
                                                           :|We are that good!|
                                                           (/ 1.0 delta))))
                        (len (length status)))
                   (ctl (:clr 1 (1+ len) 1 cols))
                   (out (:col 1 :row 1) status))
                 (ctl (:fgc #xff #xa0 #xa0)
                      (:bgc #x22 #x22 #x22))))))
#+END_SRC

Now we'll define the class for a frame. A frame will be defined by its
clipping region and a rendering function.

#+BEGIN_SRC lisp
  (defclass frame ()
    ((rfn :initarg :rfn :accessor rfn :documentation "Rendering function.")
     (fsz :initarg :fsz :accessor fsz :documentation "Frame dimensions.")))

  (defun render-frame (frame)
    (destructuring-bind (r1 c1 r2 c2) (fsz frame)
      (with-clipping (:row1 r1 :col1 c1 :row2 r2 :col2 c2)
        (funcall (rfn frame) frame))))
#+END_SRC

For amusement and to have something to render, we'll define three
demos to illustrate some issues.

The noise demo is like a white noise, but in color :-). It fills each
cell with a different random color. We will use it as the rendering
performance benchmark and to illustrate how overlapping frames behave.

#+BEGIN_SRC lisp
  (defun make-noise-frame (r1 c1 r2 c2)
    (flet ((make-noise-renderer (color)
             (lambda (frame)
               (destructuring-bind (r1 c1 r2 c2) (fsz frame)
                 (loop for row from r1 upto r2
                       do (loop for col from c1 upto c2
                                do (out (:row row
                                         :col col
                                         :bgc `(0 0 0)
                                         :fgc color)
                                        (alexandria:random-elt '("+" "-")))))))))
      (make-instance 'frame
                     :rfn (make-noise-renderer
                           (list (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))))
                     :fsz (list r1 c1 r2 c2))))
#+END_SRC

The animation demo will show a moving square bouncing from the frame
edges. We will use it to illustrate a flicker which happens when we
first clear the background and then draw it content even when the FPS
rate is high. The animation speed does not depend on the fps.

#+BEGIN_SRC lisp
  (defun make-animation-frame (r1 c1 r2 c2 speed)
    (let ((last-time (get-internal-real-time))
          (dc 1)
          (current-row (truncate (+ r1 r2) 2))
          (current-col (+ c1 2)))
      (flet ((draw-square ()
               (ctl (:bgc #x44 #x44 #x00)
                    (:fgc #xff #xbb #x00)
                    (:clr r1 c1 r2 c2))
               (let* ((now (get-internal-real-time))
                      (delta (- now last-time))
                      (seconds (/ delta internal-time-units-per-second)))
                 (incf current-col (* seconds speed dc))
                 (setf last-time now))
               (cond ((>= (+ current-col 2) c2)
                      (setf dc -1))
                     ((<= (- current-col 2) c1)
                      (setf dc +1)))
               (setf current-col
                     (alexandria:clamp current-col (+ c1 2) (- c2 2)))
               (loop with row = current-row
                     with col = (round current-col)
                     for r from (1- row) upto (1+ row)
                     do (loop for c from (- col 2) upto (+ col 2)
                              do (out (:row r :col c) "#")))))
        (make-instance 'frame
                       :rfn (lambda (frame)
                              (declare (ignore frame))
                              (draw-square))
                       :fsz (list r1 c1 r2 c2)))))
#+END_SRC

The event demo is a stub for now. Later it will print events passed to
it, for now it prints outside the frame. We will use it to illustrate
a need for scroll bars and for the offset abstraction when the content
goes beyond the frame dimensions and to reveal an interesting bug in
the ~out~ macro.

#+BEGIN_SRC lisp
  (defun make-report-frame (r1 c1 r2 c2)
    (flet ((reporter (frame)
             (declare (ignore frame))
             (let ((str "I would like to report an event here!"))
               (loop with rows = (+ (- r2 r1) 3)
                     with col = (- c1 2)
                     for row from (1- r1) upto (1+ r2)
                     for id = (- row r1 -2)
                     for string = (format nil "XXX ~d/~d: ~a" id rows str)
                     do (out (:row row :col col :fgc '(#xff #x88 #x88)) string)))))
      (make-instance 'frame
                     :rfn #'reporter
                     :fsz (list r1 c1 r2 c2))))
#+END_SRC

Finally we'd like to see them on the screen, so we'll bind a few
controls.

- ~C-n~ will create four rather small frames: two overlapping noise
  frames, one animation frame and one event reporting frame
- ~C-m~ will create one maximized noise frame
- ~C-u~ will toggle activation of a random frame

Add the following clauses to cond in ~handle-event~:

#+BEGIN_SRC lisp
  (defun handle-event (fm event)
    #|...|#
    (cond
      #|...|#
      ((keyp event #\N :c)
       (reset)
       (setf (frames fm)
             (list (make-noise-frame 4  2 12 20)
                   (make-noise-frame 6 12 14 30)
                   (make-animation-frame 4 36 10 78 20)
                   (make-report-frame 18 10 23 20))))
      ((keyp event #\M :c)
       (reset)
       (setf (frames fm)
             (list (make-noise-frame 2
                                     1
                                     (rows *console*)
                                     (cols *console*)))))
      ((keyp event #\U :c)
       (if (active fm)
           (setf (active fm) nil)
           (alexandria:when-let ((frs (frames fm)))
             (setf (active fm) (alexandria:random-elt frs)))))))
#+END_SRC

We also want to have window decorations. On a terminal the space is
limited and each character is precious. That's why we'll draw
decorations only on the right border of the frame. Desired behavior:

- press "x" to close the frame
- press "o" to maximize the frame ("v" to reverse)
- press ">" to minimize the frame ("<" to reverse)
- drag " " to move the frame
- drag "/" to resize the frame
- when the frame output exceeds its size, add scroll bars

#+BEGIN_SRC lisp
  (defun render-window (frame)
    (destructuring-bind (wr1 wc1 wr2 wc2) (fsz frame)
      (declare (ignore wc1))
      (when (= wr2 (first *row2*))
        (return-from render-window
          (render-frame frame)))
      (ctl (:bgc #x11 #x11 #x11)
           (:fgc #xbb #xbb #xbb))
      (let ((col (1+ wc2)))
        (out (:row wr1 :col col :fgc '(#xff #x22 #x44)) "x")
        (out (:row (+ wr1 1) :col col) "o")
        (out (:row (+ wr1 2) :col col) ">")
        (loop for row from (+ wr1 3) upto wr2
              do (out (:row row :col col) " "))
        (out (:row (- wr2 0) :col col) "/"))
      (ctl (:bgc #x22 #x22 #x22)
           (:fgc #xbb #xbb #xbb))
      (render-frame frame)))

  (defun display-screen (fm)
    (alexandria:if-let ((frame (active fm)))
      (render-window frame)
      (dolist (frame (frames fm))
        (render-window frame))))
#+END_SRC

Now press C-n to see a few frames and press C-m to see our baseline
performance benchmark. Now we can move forward to test things.

#+CAPTION: New examples in action.
#+NAME:   fig:examples
[[./static/02-examples.webm]]


* Rethinking I/O

WE HAVE A TECHNICAL DEBT! Ha, of course we do. We've remarked some of
the earlier. Let's repeat them:

- flicker when we clear the screen (or due to the overlap)
- lingering glitches on the screen after the terminal resize
- function get-cursor-position may discard pending characters
- no means to map input to the receiving element
- no means to translate drawing position (i.e "move" the frame)

Right now our I/O is synchronous with the terminal. When we call ~out~
or ~ctl~, the characters are sent to it immedietely, and we read the
input with ~read-input~ until the stream is empty. It is a very simple
model and simple models tend to be hard to use efficiently. We'll
settle on _easy_ instead of _simple_.

This program, when renderering on the area 80x24, yields very
unimpressive 40fps on all three terminals I've tried it with. If we
add ~(ctl (:clr 1 1 rows cols))~ before the loop in ~render-frame~
we'll also notice a significant flicker. We can't write games like
this! If we modify the function put to inhibit actual writing to the
console we'll notice, that this operation is the bottleneck.

#+BEGIN_SRC lisp
  (defvar *inhibit* nil)
  (defun put (&rest args)
    "Put raw string on a console"
    (unless *inhibit*
      (format *console-io* "~{~a~}" args)
      (finish-output *console-io*)))

  (defun start-display ()
    #| ... |#
    (let ((*inhibit* t))
      (render-frame (1- rows) cols))
    #| ... |#)
#+END_SRC

That gives us whooping 500-1000fps, so clearly we need to write to the
console as little as possible. The rest of the time is spent on
looping over cells and doing things like picking a random color. In
ideal world we'd touch each cell at most once for each frame. In our
sample code we write far more bytes than one per cell, because we also
send escape sequences for background and foreground -- that shows how
very inefficient is our approach with the macro ~out~ restoring the
initial state upon exit and always re-positioning the cursor. First
let's count how many characters per frame do we print. Once again
we'll abuse the function ~put~ to count that for us.

#+BEGIN_SRC lisp
  (defvar *count* nil)
  (defun put (&rest args)
    "Put raw string on a console"
    (let* ((payload (format nil "~{~a~}" args))
           (length (length payload)))
      (when *count*
        (incf *count* length))
      (princ payload *console-io*)
      (finish-output *console-io*)))

  (defun start-display ()
    #| ... |#
    (let (start stop delta count)
      (setf start (get-internal-real-time))
      (let ((*count* 0))
        (render-frame (1- rows) cols)
        (setf count *count*))
      (setf stop (get-internal-real-time))
      (setf delta (/ (- stop start)
                     internal-time-units-per-second))
      (ctl (:fgc #x22 #x22 #x22)
           (:bgc #xbb #xbb #xbb))
      (out (:col 1 :row rows)
           (format nil "Rows ~3d, Cols ~3d, FPS ~8,2f, chars ~8d"
                   (1- rows) cols (if (zerop delta)
                                      :|We are that good!|
                                      (/ 1.0 delta))
                   count)))
    #| ... |#)
#+END_SRC

If we were only printing text without positioning the cursor, that
would be 1920 characters on 24x80 terminal. Clearly that's not the
case, on my terminal the number is around 150000, so we print 78x
more! Let's experiment a little and skip setting the color.

#+BEGIN_SRC lisp
  (defun render-frame (rows cols)
    (loop for row from 1 upto rows
          do (loop for col from 1 upto cols
                   for c.g = (alexandria:random-elt '(#x44 #x44 #x44 #x44 #x66))
                   do (out (:row row
                            :col col
                            ;; :bgc `(0 0 0)
                            ;; :fgc (list #x00 c.g #x44)
                            )
                           (alexandria:random-elt '("+" "-"))))))
#+END_SRC

Lousy 40fps becomes 120fps and we print exactly 27864 characters per
each frame. That gives us the terminal speed which is around 3343680
characters per second. Notice, that not setting row and col in out
macro doesn't change anything because of how the macro is constructed.
If we replace the call to the macro ~out~ with ~put~ though, we
benefit from line wrapping and we have exactly 1920 characters printed
with 333-500fps. Now let's assume that each cell has different
background and foreground color.

#+BEGIN_SRC lisp
  (defun render-frame (rows cols)
    (loop for row from 1 upto rows
          do (loop for col from 1 upto cols
                   for c.g = (alexandria:random-elt '(#x44 #x44 #x44 #x44 #x66))
                   do (ctl (:bgc 0 0 0)
                           (:fgc 0 c.g #x44))
                      (put (alexandria:random-elt '("+" "-"))))))
#+END_SRC

So if we assume, that each cell is drawn only once and that we do not
explicitly manipulate the cursor position, we have 56050 characters
and an acceptable 100-111fps on 24x80 terminal. Our performance drops
when we grow the terminal. For instance:

| col;row | fps (out) | fps (ctl+put) | fps (put) |
|---------+-----------+---------------+-----------|
|   80x24 |     41-45 |       100-111 |   333-500 |
|   80x80 |     11-12 |         20-30 |   111-125 |
|  158x82 |       5-6 |         10-12 |     55-60 |
|  318x82 |       2-3 |           4-5 |     29-30 |

Of course we can't expect the programmer to always start from the
first column and to never draw over the already filled cell. We will
introduce in-memory buffers which will be flushed when the frame is
complete. Since we assume, that writing to the console is always the
bottleneck, we will in fact maintain two buffers and update only cells
which are different. It won't have big impact for the white noise, but
for regular applications it will be a win.
