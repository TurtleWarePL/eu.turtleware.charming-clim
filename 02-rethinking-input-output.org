#+title: Charming CLIM tutorial part 2 – Rethinking I/O
#+author: Daniel 'jackdaniel' Kochmański
#+email: daniel@turtleware.eu
#+hugo_base_dir: ~/hugo/

This is the second part of a tutorial about building a McCLIM backend
for the terminal starting from zero. After reading [[https://turtleware.eu/posts/Controlling-the-terminal.html][the first issue]] we
should have a good grasp of how to control and read input from the
terminal. It is time to refine things for efficiency and ease of use.
If you didn't follow the last part, here is the archive with the
[[https://turtleware.eu/static/misc/01-controlling-the-terminal.tar.gz][source code]] which will serve as a starter for this post. If you like
this kind of work, you can [[https://www.patreon.com/jackdaniel_kochmanski][toss a coin to your Lisper]] :-).

Right now our I/O is synchronous with the terminal. When we call ~out~
or ~ctl~, the characters are sent to it immedietely, and we read the
input with ~read-input~ until the stream is empty. The model
introduced in the previous post is certainly simple, but simple models
tend to be hard to use efficiently . We'll settle on _easy_ instead.

* Extending examples

Let's construct a few examples which will help us to identify some
problems. First move functions ~start-display~, ~show-screen~ and
~user-action~ to a separate file ~examples.lisp~ (don't forget to add
this file to the system definition).

First we'll rework slightly our abstraction. First of all we'll
introduce a frame-manager class which will be responsible for
multiplexing input and output on the screen. It has two slots:

- frames :: a list of managed windows
- active :: the active window

For a time being when there is an active frame, only this frame is
rendered. Otherwise all frames are rendered.

All events will be passed to the function ~handle-event~. We'll bind
few keys initially: C-q will exit the application and C-r will remove
all frames and clear the screen.

#+BEGIN_SRC lisp
  (defclass frame-manager ()
    ((frames :initarg :frames :accessor frames :documentation "All frames.")
     (active :initarg :active :accessor active :documentation "Active frame."))
    (:default-initargs :frames nil :active nil))

  (defun handle-event (fm event)
    (flet ((reset ()
             (setf (frames fm) nil
                   (active fm) nil)
             (clear-console)))
      (cond ((keyp event #\Q :c)
             (cl-user::quit))
            ((keyp event #\R :c)
             (reset)))))

  (defun display-screen (fm)
    (alexandria:if-let ((frame (active fm)))
      (render-frame frame)
      (dolist (frame (frames fm))
        (render-frame frame))))

  (defun render-frame (huh?)
    (declare (ignore huh?))
    (error "niy!"))
#+END_SRC

Now let's refactor the function ~start-display~. It will a modeline at
the top and display the terminal dimensions and the frame rate.
Moreover it will create a frame manager and will be responsible for
calling previously defined functions. When we start the application,
we'll see a heart warming message "We are that good!", meaning that we
are too fast to measure the FPS.

#+BEGIN_SRC lisp
  (defun start-display ()
    (swank:create-server)
    (with-console (:ios *terminal-io*)
      (clear-console)
      (loop with rows = (rows *console*)
            with cols = (cols *console*)
            with fm = (make-instance 'frame-manager)
            do (when *console-dirty-p*
                 (update-console-dimensions)
                 (setf rows (rows *console*)
                       cols (cols *console*)))
            do (loop for ch = (read-input)
                     until (null ch)
                     do (handle-event fm ch))
            do (let (start stop delta)
                 (setf start (get-internal-real-time))
                 (display-screen fm)
                 (setf stop (get-internal-real-time))
                 (setf delta (/ (- stop start)
                                internal-time-units-per-second))
                 (ctl (:fgc #x22 #x22 #x22)
                      (:bgc #xbb #xbb #xbb))
                 (let* ((status (format nil "Rows ~3d, Cols ~3d, FPS ~8,2f"
                                        (1- rows) cols (if (zerop delta)
                                                           :|We are that good!|
                                                           (/ 1.0 delta))))
                        (len (length status)))
                   (ctl (:clr 1 (1+ len) 1 cols))
                   (out (:col 1 :row 1) status))
                 (ctl (:fgc #xff #xa0 #xa0)
                      (:bgc #x22 #x22 #x22))))))
#+END_SRC

Now we'll define the class for a frame. A frame will be defined by its
clipping region and a rendering function.

#+BEGIN_SRC lisp
  (defclass frame ()
    ((rfn :initarg :rfn :accessor rfn :documentation "Rendering function.")
     (fsz :initarg :fsz :accessor fsz :documentation "Frame dimensions.")))

  (defun render-frame (frame)
    (destructuring-bind (r1 c1 r2 c2) (fsz frame)
      (with-clipping (:row1 r1 :col1 c1 :row2 r2 :col2 c2)
        (funcall (rfn frame) frame))))
#+END_SRC

For amusement and to have something to render, we'll define three
demos to illustrate some issues.

The noise demo is like a white noise, but in color :-). It fills each
cell with a different random color. We will use it as the rendering
performance benchmark and to illustrate how overlapping frames behave.

#+BEGIN_SRC lisp
  (defun make-noise-frame (r1 c1 r2 c2)
    (flet ((make-noise-renderer (color)
             (lambda (frame)
               (destructuring-bind (r1 c1 r2 c2) (fsz frame)
                 (loop for row from r1 upto r2
                       do (loop for col from c1 upto c2
                                do (out (:row row
                                         :col col
                                         :bgc `(0 0 0)
                                         :fgc color)
                                        (alexandria:random-elt '("+" "-")))))))))
      (make-instance 'frame
                     :rfn (make-noise-renderer
                           (list (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))))
                     :fsz (list r1 c1 r2 c2))))
#+END_SRC

The animation demo will show a moving square bouncing from the frame
edges. We will use it to illustrate a flicker which happens when we
first clear the background and then draw it content even when the FPS
rate is high. The animation speed does not depend on the fps.

#+BEGIN_SRC lisp
  (defun make-animation-frame (r1 c1 r2 c2 speed)
    (let ((last-time (get-internal-real-time))
          (dc 1)
          (current-row (truncate (+ r1 r2) 2))
          (current-col (+ c1 2)))
      (flet ((draw-square ()
               (ctl (:bgc #x44 #x44 #x00)
                    (:fgc #xff #xbb #x00)
                    (:clr r1 c1 r2 c2))
               (let* ((now (get-internal-real-time))
                      (delta (- now last-time))
                      (seconds (/ delta internal-time-units-per-second)))
                 (incf current-col (* seconds speed dc))
                 (setf last-time now))
               (cond ((>= (+ current-col 2) c2)
                      (setf dc -1))
                     ((<= (- current-col 2) c1)
                      (setf dc +1)))
               (setf current-col
                     (alexandria:clamp current-col (+ c1 2) (- c2 2)))
               (loop with row = current-row
                     with col = (round current-col)
                     for r from (1- row) upto (1+ row)
                     do (loop for c from (- col 2) upto (+ col 2)
                              do (out (:row r :col c) "#")))))
        (make-instance 'frame
                       :rfn (lambda (frame)
                              (declare (ignore frame))
                              (draw-square))
                       :fsz (list r1 c1 r2 c2)))))
#+END_SRC

The event demo is a stub for now. Later it will print events passed to
it, for now it prints outside the frame. We will use it to illustrate
a need for scroll bars and for the offset abstraction when the content
goes beyond the frame dimensions and to reveal an interesting bug in
the ~out~ macro.

#+BEGIN_SRC lisp
  (defun make-report-frame (r1 c1 r2 c2)
    (flet ((reporter (frame)
             (declare (ignore frame))
             (let ((str "I would like to report an event here!"))
               (loop with rows = (+ (- r2 r1) 3)
                     with col = (- c1 2)
                     for row from (1- r1) upto (1+ r2)
                     for id = (- row r1 -2)
                     for string = (format nil "XXX ~d/~d: ~a" id rows str)
                     do (out (:row row :col col :fgc '(#xff #x88 #x88)) string)))))
      (make-instance 'frame
                     :rfn #'reporter
                     :fsz (list r1 c1 r2 c2))))
#+END_SRC

Finally we'd like to see them on the screen, so we'll bind a few
controls.

- ~C-n~ will create four rather small frames: two overlapping noise
  frames, one animation frame and one event reporting frame
- ~C-m~ will create one maximized noise frame
- ~C-u~ will toggle activation of a random frame

Add the following clauses to cond in ~handle-event~:

#+BEGIN_SRC lisp
  (defun handle-event (fm event)
    #|...|#
    (cond
      #|...|#
      ((keyp event #\N :c)
       (reset)
       (setf (frames fm)
             (list (make-noise-frame 4  2 12 20)
                   (make-noise-frame 6 12 14 30)
                   (make-animation-frame 4 36 10 78 20)
                   (make-report-frame 18 10 23 20))))
      ((keyp event #\M :c)
       (reset)
       (setf (frames fm)
             (list (make-noise-frame 2
                                     1
                                     (rows *console*)
                                     (cols *console*)))))
      ((keyp event #\U :c)
       (if (active fm)
           (setf (active fm) nil)
           (alexandria:when-let ((frs (frames fm)))
             (setf (active fm) (alexandria:random-elt frs)))))))
#+END_SRC

We also want to have window decorations. On a terminal the space is
limited and each character is precious. That's why we'll draw
decorations only on the right border of the frame. Desired behavior:

- press "x" to close the frame
- press "o" to maximize the frame ("v" to reverse)
- press ">" to minimize the frame ("<" to reverse)
- drag " " to move the frame
- drag "/" to resize the frame
- when the frame output exceeds its size, add scroll bars

#+BEGIN_SRC lisp
  (defun render-window (frame)
    (destructuring-bind (wr1 wc1 wr2 wc2) (fsz frame)
      (declare (ignore wc1))
      (when (= wr2 (first *row2*))
        (return-from render-window
          (render-frame frame)))
      (ctl (:bgc #x11 #x11 #x11)
           (:fgc #xbb #xbb #xbb))
      (let ((col (1+ wc2)))
        (out (:row wr1 :col col :fgc '(#xff #x22 #x44)) "x")
        (out (:row (+ wr1 1) :col col) "o")
        (out (:row (+ wr1 2) :col col) ">")
        (loop for row from (+ wr1 3) upto wr2
              do (out (:row row :col col) " "))
        (out (:row (- wr2 0) :col col) "/"))
      (ctl (:bgc #x22 #x22 #x22)
           (:fgc #xbb #xbb #xbb))
      (render-frame frame)))

  (defun display-screen (fm)
    (alexandria:if-let ((frame (active fm)))
      (render-window frame)
      (dolist (frame (frames fm))
        (render-window frame))))
#+END_SRC

Now press C-n to see a few frames and press C-m to see our baseline
performance benchmark. Now we can move forward to test things.

#+CAPTION: New examples in action.
#+NAME:   fig:examples
[[./static/02-examples.webm]]

Looking at our examples we can easily spot a few problems:

- the last two columns are not shown in the event demo
- a small frame rate in the full screen noise demo (~40fps)
- overlapping windows flicker and overexpose their output
- flickering with the background in the animation demo

The first issue is because we have a bug! When we render text in the
event reporter demo, we start from a column which is two characters
before the clipping area beginning. Looking at the macro ~out~ we have
there the following loop:

#+BEGIN_SRC lisp
  (loop for c from col
        for s across str
        when (inside row c)
          do (put s))
#+END_SRC

Increasing the cursor position is an implicit side-effect of calling
put. So when the character does not fit inside the clipping region, we
leave the cursor at its previous position. That's why in fact we start
drawing before the clipping region. We need to advance the cursor
manually. Since we are at it, we will add a few more escape sequences:

#+BEGIN_SRC lisp
  (macrolet ((moveit (endch)
               `(if (= n 1)
                    (csi ,endch)
                    (csi n ,endch))))
    (defun cursor-up    (&optional (n 1)) (moveit "A"))
    (defun cursor-down  (&optional (n 1)) (moveit "B"))
    (defun cursor-right (&optional (n 1)) (moveit "C"))
    (defun cursor-left  (&optional (n 1)) (moveit "D")))

  (defmacro out (#|...|#)
    `(let (#|...|#)
       #|...|#
       (loop for c from col
             for s across str
             if (inside row c)
               do (put s)
             else
               do (cursor-right))))
#+END_SRC

* Rethinking output

** Analysis

When we render the noise demo on the area 80x24 the frame rate is very
unimpressive – around 40 fps. We can't write games like this!  We'll
take a look at the function ~put~ which is responsible for the actual
writing on the terminal. It has a call to ~finish-output~, but we
don't need it to be called after each call. We'll put that at the end
of the rendering loop instead. Don't forget to change
~get-cursor-position~ to do that, otherwise we may get stuck during
startup!

#+BEGIN_SRC lisp
  (defun put (&rest args)
    "Put raw string on a console"
    (format *console-io* "~{~a~}" args))

  (defun start-display ()
    #|...|#
    (loop #|...|#
          do (finish-output *console-io*)))

  (defun get-cursor-position ()
    (request-cursor-position)
    (finish-output *console-io*) ; <-----
    (handler-case (loop (read-input))
      (cursor-position-report (c)
        (values (row c) (col c)))))
#+END_SRC

Aha, Jackpot! Our rendering is now twice as fast as before with a
staggering 100 frames per second. Let's go one step further and
inhibit all writing to the terminal.

#+BEGIN_SRC lisp
  (defvar *inhibit* nil)
  (defun put (&rest args)
    "Put raw string on a console"
    (unless *inhibit*
      (format *console-io* "~{~a~}" args)))

  (defun display-screen (fm)
    (let ((*inhibit* t))
      (alexandria:if-let ((frame (active fm)))
        (render-window frame)
        (dolist (frame (frames fm))
          (render-window frame)))))
#+END_SRC

That gives us whooping 500-1000fps on 80x24 window (what is the upper
limit of the measurement which is based on the internal time). Clearly
our rendering is I/O bound at the moment. Notice though, that even now
when we resize the terminal (and recreate the frame) to i.e 158x84
we'll have a frame rate around 111fps, which is not that impressive.
There is certainly merit in optimizing for the CPU time after we fix
the bottleneck with I/O.

We need to write to the console as little as possible. The rest of the
time is spent on looping over cells and doing things like picking a
random color. Ideally we'd write at most one character in each cell,
but we also do other things, like setting the cursor position and
colors. It is time for us to count characters per frame! We can't do
better than 80x24 = 1920 with the noise demo.

#+BEGIN_SRC lisp
  (defvar *count* nil)
  (defun put (&rest args)
    "Put raw string on a console"
    (let* ((payload (format nil "~{~a~}" args))
           (length (length payload)))
      (when *count*
        (incf *count* length))
      (princ payload *console-io*)
      (finish-output *console-io*)))

  (defun start-display ()
    #| ... |#
    (let (start stop delta count)
      #|...|#
      (let ((*count* 0))
        (display-screen fm)
        (setf count *count*))
      #|...|#
      (out (:col 1 :row rows)
           (format nil "Rows ~3d, Cols ~3d, FPS ~8,2f, chars ~8d"
                   (1- rows) cols (if (zerop delta)
                                      :|We are that good!|
                                      (/ 1.0 delta))
                   count)))
    #| ... |#)
#+END_SRC

Let's remind ourselves what is the current shape of the function
~make-noise-frame~, we'll tinker with it to compare different
approaches:

#+BEGIN_SRC lisp
  (defun make-noise-frame (r1 c1 r2 c2)
    (flet ((make-noise-renderer (color)
             (lambda (frame)
               (destructuring-bind (r1 c1 r2 c2) (fsz frame)
                 (loop for row from r1 upto r2
                       do (loop for col from c1 upto c2
                                do (out (:row row
                                         :col col
                                         :bgc (alexandria:random-elt
                                               `((0 0 0) (8 8 8)))
                                         :fgc color)
                                        (alexandria:random-elt '("+" "-")))))))))
      (make-instance 'frame
                     :rfn (make-noise-renderer
                           (list (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))))
                     :fsz (list r1 c1 r2 c2))))
#+END_SRC

This demo gives us 153267 characters per frame, which compared to 1920
is over 81 times more. Something went terribly wrong! Our prime
suspect is a macro ~out~. Let's put the ~out~ out of the picture.
We'll set the state manually with ~ctl~ and won't bring back the old
one. Also we won't bother we repositioning the cursor after each cell.

#+BEGIN_SRC lisp
  (defun make-noise-frame (r1 c1 r2 c2)
    (flet ((make-noise-renderer (color)
             (lambda (frame)
               (ctl (:pos r1 . c1)) ; <- set the render beginning
               (destructuring-bind (r1 c1 r2 c2) (fsz frame)
                 (loop for row from r1 upto r2
                       do (loop for col from c1 upto c2
                                do (let ((fg color)
                                         (bg (alexandria:random-elt `((0 0 0) (8 8 8)))))
                                     (ctl (:fgc (first fg) (second fg) (third fg))
                                          (:bgc (first bg) (second bg) (third bg))))
                                   (put (alexandria:random-elt '("+" "-")))))))))
      (make-instance 'frame
                     :rfn (make-noise-renderer
                           (list (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))))
                     :fsz (list r1 c1 r2 c2))))
#+END_SRC

That gives us 59526 characters per frame what is almost thrice as
fast. Now let's try skipping setting the color whatsoever.

#+BEGIN_SRC lisp
  (defun make-noise-frame (r1 c1 r2 c2)
    (flet ((make-noise-renderer (color)
             (lambda (frame)
               (ctl (:pos r1 . c1)) ; <- set the render beginning
               (destructuring-bind (r1 c1 r2 c2) (fsz frame)
                 (loop for row from r1 upto r2
                       do (loop for col from c1 upto c2
                                do (put (alexandria:random-elt '("+" "-")))))))))
      (make-instance 'frame
                     :rfn (make-noise-renderer
                           (list (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))))
                     :fsz (list r1 c1 r2 c2))))
#+END_SRC

Aha, 1926 characters! Setting the cursor position accounts for the
remaining 6 characters ~ESC [ 2 ; 1 H~. So truly the macro ~out~ is
our culprit.

Here is a short comparison of these approaches. ~out~ brings back the
old state, ~ctl+put~ sets the color for each cell but doesn't restore
the old state, and ~put~ sets the position only once and writes to
consecutive cells (no color). Numbers are ~fps / chars-per-frame~. The
throughput of my terminal is roughly 10M characters per second.

| col;row | out           | ctl+put      | put          |
|---------+---------------+--------------+--------------|
|   80x24 | 100 / 154664  | 250 / 61446  | 500+ / 1926  |
|   80x80 | 19  / 517040  | 77  / 211206 | 500+ / 6406  |
|  159x86 | 8   / 1097034 | 14  / 423900 | 333  / 13680 |
|  319x86 | 5   / 2210304 | 10  / 877894 | 166  / 27440 |

These numbers may differ in case of examples with colors, because they
are selected randomly, and printing ~255;255;255~ consumes obviously
more characters than i.e ~42;42;42~. Also note, that this is the worst
case scenario where we change colors for each cell of both background
and foreground. Usually numbers should be much more favorable to us.

#+CAPTION: New examples in action.
#+NAME:   fig:examples
[[./static/02-examples.webm]]

As we can see, a major bottlenecks are:
- bringing back the old state of a medium
- repositioning the cursor for output
- changing foreground and background color

Sometimes changing color is not necessary, because it does not change
from cell to cell. For instance in the noise demo the foreground color
doesn't change and only the background color is picked randomly.

** Refining interfaces

Being able to draw anywhere on the screen with color is certainly
useful feature and demanding from the programmer to print only to
consecutive cells would be bold. Bringing back the old state is also
nice because there is no need for excess bookkeeping. In other words,
traits of the macro ~out~ are very reasonable and we don't want to
change them.

#+BEGIN_QUOTE David Wheeler
All problems in computer science can be solved by another level of
indirection.
#+END_QUOTE

... except for the problem of too many layers of indirection. As you
may guess, we'll introduce a layer of indirection to the console
access. Macros ~out~ and ~ctl~ will manipulate a virtual buffer with
virtual cells which have properties like colors and content. Our
interface will be split between the low level for direct terminal
access and the high level for convenient use. That way we'll have both
_simple_ and _easy_ interfaces available. We will extend them when
needed. Create a new file ~packages.lisp~ and add it to the system
definition.

#+BEGIN_SRC lisp
  (defpackage #:eu.turtleware.charming-clim.terminal/ll
    (:export #:init-console
             #:close-console

             #:put #:esc #:csi #:sgr
             #:read-input #:set-alt-is-meta #:keyp

             #:reset-console
             #:clear-console
             #:clear-rectangle
             #:clear-line
             #:set-foreground-color
             #:set-background-color

             #:with-cursor-position
             #:set-cursor-position
             #:save-cursor-position
             #:restore-cursor-position
             #:request-cursor-position

             #:cursor-up
             #:cursor-down
             #:cursor-right
             #:cursor-left

             #:set-cursor-visibility
             #:set-mouse-tracking))

  (defpackage #:eu.turtleware.charming-clim.terminal/hl
    (:export #:with-console
             #:make-vbuf
             #:with-vbuf
             #:out #:ctl))

  (defpackage #:eu.turtleware.charming-clim
    (:use #:common-lisp
          #:eu.turtleware.charming-clim.terminal/ll
          #:eu.turtleware.charming-clim.terminal/hl))
#+END_SRC

Notice, that all implementation is done in a single package, namely
~eu.turtleware.charming-clim~. That is a deliberate choice which saves
us from the package hell. We'll take this opportunity to rename "setf"
functions to something more consistent with other symbols:

- ~(setf cursor-visibility)~ -> ~set-cursor-visibility~
- ~(setf mouse-tracking)~    -> ~set-mouse-tracking~
- ~(setf alt-is-meta)~       -> ~set-alt-is-meta~

Change these names and adjust all references in the source code now.


** Virtual buffers



** flicker 
Flicker is caused by the fact, that we draw multiple times on the same
cell. In case of the animation it is first drawing the background and
then drawing the square, and for overlapping windows it is rendering
windows sequentially. Coincidentally these issues will be solved by
the solution for the slow frame rate. Since we are at it, we should
consider a few things about rendering frames in windows:

- moving the window requires the translation transformation API
- when part of the window is not visible we may not draw it
- for a static content it is enough to redraw a damaged region
- a dynamic content depends on a hidden state (i.e the time)

To allow moving windows we'll introduce a new macro ~with-drawing~
which will allow specifying the output transformation. It will also
subsume the functionality of a macro ~with-clipping~ which will be
removed.



#+BEGIN_SRC lisp

#+END_SRC

To allow moving windows we'll replace the macro ~with-clipping~ with a
new one called ~with-drawing~. It will accept the same arguments as
~with-clipping~ and additionally arguments ~trow~, ~crow~ and ~tran-fn~. 

To address these points we will replace the macro ~with-clipping~ with
another one subsuming its behavior, which will be called
~with-drawing~. 
