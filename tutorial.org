#+title: Charming CLIM tutorial part 1 – controlling the terminal
#+author: Daniel 'jackdaniel' Kochmański

When building a console backend for McCLIM there are three terminal
capabilities that we need:

- configuring the terminal (raw mode, no echo, querying properties)
- drawing output (positioning cursor and writing with attributes)
- reading events (keyboard, pointer and window status changes)

* Configuring the terminal

To know where the terminal is, we need to start the implementation
from it and save the streams in a separate variable, because SWANK
rebind them for the SLIME session.

#+BEGIN_SRC common-lisp
(defvar *console-io* *terminal-io*)
(swank:create-server)
(loop (sleep most-positive-fixnum))
#+END_SRC

Most things may be implemented with ANSI escape sequences and various
extensions to them. Unfortunately we can't turn off echo and line
buffering from that way, we need to use a minimal C program to do
that, which we will call with FFI.

#+BEGIN_SRC c
  /* This small program is written based on a tutorial found under URL:
     https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html */

  #include <stdlib.h>
  #include <termios.h>
  #include <unistd.h>

  struct termios *enable_raw() {
    struct termios *orig_termios = malloc(sizeof(struct termios));
    struct termios raw;
    tcgetattr(STDIN_FILENO, orig_termios);
    raw = *orig_termios;
    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
    raw.c_oflag &= ~(OPOST);
    raw.c_cflag |= (CS8);
    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
    return orig_termios;
  }

  void disable_raw(struct termios *orig_termios) {
    tcsetattr(STDIN_FILENO, TCSAFLUSH, orig_termios);
    free(orig_termios);
  }
#+END_SRC

And here's how we will use it. Compiling the C file and loading the
resulting shared library will be performed by ASDF but instructions
how to do it manually are included in a comment. To allow interactive
programming we'll use a function ~show-screen~ which will be called
each second.

#+BEGIN_SRC common-lisp
  (defpackage #:eu.turtleware.charming-clim
    (:use #:cl)
    (:export #:start-display))
  (in-package #:eu.turtleware.charming-clim)

  ;; gcc raw-mode.c -shared -o raw-mode.so
  ;; (cffi:load-foreign-library "/path/to/raw-mode.so")

  (cffi:defcfun (enable-raw "enable_raw")
      :pointer)
  (cffi:defcfun (disable-raw "disable_raw")
      :void
    (handler :pointer))

  (defvar *console-io* *terminal-io*)

  (defmacro with-console (opts &body body)
    (declare (ignore opts))
    (let ((handler (gensym)))
      `(let ((,handler (enable-raw)))
         (unwind-protect (progn ,@body)
           (disable-raw ,handler)))))

  (declaim (notinline show-screen))
  (defun show-screen ()
    (format *console-io* "~acHello World!" #\esc)
    (finish-output *console-io*))

  (defun start-display ()
    (swank:create-server)
    (with-console ()
      (loop (sleep 1)
            (show-screen))))
#+END_SRC

Finally, to wrap things up, we need to define a loadable system. Let's
name the C file "raw-mode.c", and the Lisp file "terminal.lisp". The
directory will have a flat structure with the ASDF definition file
~eu.turtleware.charming-clim.asd~.

#+BEGIN_SRC lisp
  (defpackage #:charming-clim-system
    (:use #:asdf #:cl)
    (:export #:cfile))
  (in-package #:charming-clim-system)

  (defclass cfile (c-source-file) ())

  (defmethod output-files ((o compile-op) (c cfile))
    (list (make-pathname :name (component-name c) :type "so")))

  (defmethod perform ((o compile-op) (c cfile))
    (let ((in  (first (input-files o c)))
          (out (first (output-files o c))))
      (uiop:run-program (format nil "cc -shared ~a -o ~a" in out))))

  (defmethod perform ((o load-op) (c cfile))
    (let ((in (first (input-files o c))))
      (uiop:call-function "cffi:load-foreign-library" in)))

  (defmethod operation-done-p ((o compile-op) (c cfile))
    (let ((in  (first (input-files o c)))
          (out (first (output-files o c))))
      (and (probe-file in)
           (probe-file out)
           (> (file-write-date out) (file-write-date in)))))

  (defsystem "eu.turtleware.charming-clim"
    :defsystem-depends-on (#:cffi)
    :depends-on (#:cffi #:swank)
    :components ((:static-file "tutorial.org")
                 (:cfile "raw-mode")
                 (:file "terminal")))
#+END_SRC

Now it is enough to load the system ~eu.turtleware.charming-clim~ in a
terminal (not in Emacs!), and call the function ~start-display~ to see
on the screen a string "Hello World!". Now connect to a swank server
and let the hacking begin!

#+CAPTION: Hello world application in action.
#+NAME:   fig:hello-world
[[./static/hello-world.webm]]

* Escape sequences

We will control the terminal by using ANSI escape sequences and with
some few extensions to receive the pointer evetns. To understand
better how escape sequences work you may read into the following:articles:

- wikipedia article :: https://en.wikipedia.org/wiki/ANSI_escape_code
- control sequences :: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html
- standard ecma-48  :: https://www.ecma-international.org/publications/standards/Ecma-048.htm

Escape sequences usually start with the control sequence introducer
and may accept parameters. Numbers are encoded with digit characters
with delimiters. Character case matters. Let's define a few utilities.

#+BEGIN_SRC common-lisp
  (defun put (&rest args)
    "Put raw string on a console"
    (format *console-io* "~{~a~}" args)
    (finish-output *console-io*))

  (defun esc (&rest args)
    "Escape sequence"
    (apply #'put (code-char #x1b) args))

  (defun csi (&rest args)
    "Control sequence introducer"
    (apply #'esc #\[ args))

  (defun sgr (&rest args)
    "Select Graphic Rendition"
    (apply #'csi (append args '("m"))))
#+END_SRC

Time to add a high level interface. These few functions illustrate how
the terminal is controlled. We'll add more functions when we need them.

#+BEGIN_SRC lisp
  (defun reset-console ()
    "Clears the screen, attributes, cursor position etc."
    (esc "c"))

  (defun clear-console (&optional (mode 2))
    "Erase in display"
    ;; Defined modes:
    ;; 0 - clear from cursor to the end of the display
    ;; 1 - clear from cursor to the start of the display
    ;; 2 - clear entire display
    (csi mode "J"))

  (defun clear-line (&optional (mode 2))
    "Erase in line."
    ;; Defined modes:
    ;; 0 - clear from cursor to the end of the line
    ;; 1 - clear from cursor to the start of the line
    ;; 2 - clear entire line
    (csi mode "K"))

  (defun set-foreground-color (r g b)
    (sgr "38;2;" r ";" g ";" b))

  (defun set-background-color (r g b)
    (sgr "48;2;" r ";" g ";" b))

  (defun save-cursor-position ()
    (csi "s"))

  (defun restore-cursor-position ()
    (csi "u"))

  (defun set-cursor-position (row col)
    (cond ((and row col)
           (csi row ";" col "H"))
          ((not (null col))
           (csi row ";H"))
          ((not (null row))
           (csi ";" col "H"))))

  (defmacro with-cursor-position ((row col) &body body)
    `(progn
       (save-cursor-position)
       (set-cursor-position ,row ,col)
       (unwind-protect (progn ,@body)
         (restore-cursor-position))))

  (defun (setf cursor-visibility) (visiblep)
    (if visiblep
        (csi "?" 2 5 "h")
        (csi "?" 2 5 "l")))
#+END_SRC

Time to something more fun. Typing the following in a REPL while the
terminal is open gives the most satisfying result. The example below
shows an important property of the terminal: first character is
addressed with a coordinate [1, 1].

#+BEGIN_SRC lisp
  (defparameter *row* 2)
  (defparameter *col* 2)
  (defparameter *dir* 1)
  (reset-console)
  (setf (cursor-visibility) nil)
  (set-background-color #x00 #x22 #x22)
  (set-foreground-color #xff #x22 #x22)

  (declaim (notinline show-screen))
  (defun show-screen ()
    (clear-console)
    (let ((str "Hello World!"))
      (set-cursor-position *row* (incf *col* *dir*))
      (cond ((>= (+ (1- *col*) (length str)) 80)
             (setf *dir* -1))
            ((<= *col* 2)
             (setf *dir* +1)))

      (with-cursor-position (*row*  1) (put "|"))
      (with-cursor-position (*row* 81) (put "|"))
      (put str)))
#+END_SRC

#+CAPTION: Red "Hello World!" moving on the screen.
#+NAME:   fig:hello-world-2
[[./static/hello-world-move-color.webm]]

Now we'll improve the loop in ~start-display~ so it is possible to
modify the configuration easily. This step will require restarting the
application because we modify the entry point (and there is no
mechanism to swap it interactively).

#+BEGIN_SRC lisp
  (defun show-screen ()
    (set-cursor-position (1+ (random 24))
                         (1+ (random 80)))
    (if (zerop (random 2))
        (put "+")
        (put "-")))

  (defparameter *conf*
    (list :sleep 1/60
          :cursorp nil
          :foreground '(#xff #xa0 #xa0)
          :background '(#x00 #x22 #x22)))

  (defun start-display ()
    (swank:create-server)
    (with-console ()
      (loop with conf
            with seconds
            do (unless (equalp conf *conf*)
                 (setf conf (copy-list *conf*))
                 (destructuring-bind (&key sleep cursorp foreground background)
                     conf
                   (setf seconds sleep)
                   (reset-console)
                   (setf (cursor-visibility) (getf conf :cursorp))
                   (apply #'set-background-color background)
                   (apply #'set-foreground-color foreground)
                   (clear-console)))
               (sleep seconds)
               (show-screen))))
#+END_SRC

* Reading input

We've configured the terminal to accept data in a raw mode. Despite
that we can only read translated sequences, there is no portable way
to access raw keycode press and release events. That is unfortunate.

There are two characters which have a special meaning. ~ESC~ starts
the escape sequence and ~DEL~ is not a graphical character (despite
not being a control characters). We will signify their uniqueness by
defining appropriate constants.

#+BEGIN_SRC lisp
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defconstant +delete+ (code-char #x7f)
      "The DEL character (#\Rubout), last in the ASCII table.")
    (defconstant +escape+ (code-char #x1b)
      "The ESC character (#\esc)."))
#+END_SRC

From the parsing perspective when we read the input we may encounter
one of the following situations:

- no characters are available
- character is a graphic character (may span few bytes)
- ESC starts the escape sequence which needs to be parsed
- DEL character is read
- character is a control character (needs to be parsed)

#+BEGIN_SRC lisp
  (defun read-input (&aux (ch (read-char-no-hang *console-io*)))
    ;; READ-CHAR may read more than one byte and return an alphanumeric
    ;; character. That's fine because we will return it as-is then.
    (cond ((or (null ch) (graphic-char-p ch))
           (return-from read-input ch))
          ((deletep ch))
          ((escapep ch))
          ((controlp ch))
          (t (error "Unknown input sequence, char code 0x~x~%." (char-code ch)))))
#+END_SRC

We will use ~read-char-no-hang~ to avoid blocking. ~read-input~ will
return either NIL (for no available input), a graphical character, a
keyword for known keys which are not graphical, or a gesture object if
there are modifiers present (or a non-graphical character appears
which has no known keyword representation).

#+BEGIN_SRC lisp
  (defclass gesture ()
    ((key  :initarg :key  :accessor gesture-key)
     (mods :initarg :mods :accessor gesture-mods)))

  (defmethod print-object ((o gesture) s)
    (print-unreadable-object (o s :type nil :identity nil)
      (let ((key (gesture-key o))
            (mods (gesture-mods o)))
        (format s "~s ~s"
                key
                (loop for p in (list +c1-mod+
                                     +meta-mod+
                                     +ctrl-mod+
                                     +alt-mod+
                                     +shift-mod+)
                      for k in '(:C1 :Meta :Ctrl :Alt :Shift)
                      unless (zerop (logand mods p))
                        collect k)))))
#+END_SRC

We may encounter four types of input: control characters (from C0 and
C1 group), escape sequences, delete character and other alphanumerical
characters. Control sequence and other modifiers like Alt must be
encoded, so we will define a simple class representing a gesture.
Character which is read from the terminal will be always either a
character, a keyword or a gesture (or null when there's no input).

#+BEGIN_SRC lisp
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defconstant  +c1-mod+   16)
    (defconstant  +meta-mod+  8)
    (defconstant  +ctrl-mod+  4)
    (defparameter +alt-mod+   2)
    (defconstant  +alt-mod*+  2)
    (defconstant  +shift-mod+ 1))

  (defclass gesture ()
    ((key  :initarg :key  :accessor gesture-key)
     (mods :initarg :mods :accessor gesture-mods)))

  (defmethod print-object ((o gesture) s)
    (print-unreadable-object (o s :type nil :identity nil)
      (let ((key (gesture-key o))
            (mods (gesture-mods o)))
        (format s "~s ~s"
                key
                (loop for p in (list +c1-mod+
                                     +meta-mod+
                                     +ctrl-mod+
                                     +alt-mod*+
                                     +shift-mod+)
                      for k in '(:C1 :Meta :Ctrl :Alt :Shift)
                      unless (zerop (logand mods p))
                        collect k)))))
#+END_SRC

~deletep~ and ~controlp~ are easy. In case of a control we return a
canonical form with a modifier and the character from the third column
of the ASCII table ~[@A-Z\[\\]^_]~. It is worth noting, that controls
from C1 group are not ASCII characters.

#+BEGIN_SRC lisp
(defun control-char-p (ch &aux (code (char-code ch)))
  (or (<= 0 code 31)
      (<= 128 code 159)))

(defun controlp (ch &aux (code (char-code ch)))
  "Predicate determining if the character is a control character.
Returns a generalized boolean (when true returns a gesture)."
  (cond ((<= 0 code 31)
         (make-instance 'gesture
                        :mods +ctrl-mod+
                        :key (code-char (+ code 64))))
        ((<= 128 code 159)
         (make-instance 'gesture
                        :mods +c1-mod+
                        :key (code-char (- code 64))))))

(defun deletep (ch)
  (when (char= ch +delete+)
    :delete))
#+END_SRC

Parsing an escape sequence requires more code. Exact sequence format
for special keys vary between terminal emulators. On top of that some
sequences are ambiguous. We are going to focus on the most widespread
ones defined by xterm, which should be compatible with most
emulators. When the escape character is read and there is no futher
input, we return ~:escape~.  Otherwise we try to parse the sequence.

#+BEGIN_SRC lisp
  (defun escapep (ch)
    (unless (char= ch +escape+)
      (return-from escapep nil))
    (alexandria:if-let ((next-ch (read-char-no-hang *console-io*)))
      ;; The escape sequence grammar: [\[NO](<num>)(;<num>)[~A-Z].
      (multiple-value-bind (num1 num2 terminator)
          (parse-escape-sequence)
        (resolve-key next-ch num1 num2 terminator))
      :escape))
#+END_SRC

When we parse the escape sequence there are few possibilities. For
instance ~ESC [~ is known as ~Control Sequence Introducer~, some
terminals produce ~ESC <char>~ when we press Alt+<char> etc. Here is
the approach we are going to take:

- if we read ~ESC <char>~ with no further input, assume Alt+<char>
- if we read ~ESC <char>~ and there is further input we try to parse
  the sequence with two optional numbers and a terminating character
- we try to resolve the character by comparing with known sequences

Function ~parse-escape-sequence~ tries to read the sequence with two
numbers defaulting to one and returns ~(values num1 num2 char)~. If
there is nothing to read, the last value is NIL. Escape sequence looks
like this: ~ESC GROUP-CHAR (NUM1) (';' NUM2) TERMINATING-CHAR~.

#+BEGIN_SRC lisp
  (defun parse-escape-sequence ()
    (let ((char (read-char-no-hang *console-io*))
          (num1 1)
          (num2 1))
      (flet ((read-num ()
               (loop while (and char (digit-char-p char))
                     collecting char into num
                     do (setf char (read-char-no-hang *console-io*))
                     finally (when num
                               (return (parse-integer (coerce num 'string)))))))
        (setf num1 (or (read-num) 1))
        (when (null char)
          (return-from parse-escape-sequence (values num1 num2 char)))
        (when (char= char #\;)
          (setf char (read-char-no-hang *console-io*)
                num2 (or (read-num) 1)))
        (values num1 num2 char))))
#+END_SRC

We want to be able to define new escape sequences when needed, so we
will create a small macro responsible for registering new
sequences. It will dispatch to the appropriate parser based on the
group and the terminator character. The function accepts two numeric
arguments.

#+BEGIN_SRC lisp
  (defvar *key-resolvers* (make-hash-table))

  (defmacro define-key-resolver (group terminator (num1 num2) &body body)
    `(setf (gethash ,(+ (char-code terminator)
                        (ash (char-code group) 8))
                    ,*key-resolvers*)
           (lambda (,num1 ,num2)
             (declare (ignorable ,num1 ,num2))
             ,@body)))
#+END_SRC

Some escape sequences are used to encode keys. In that case the second
number represents modifiers. When it is decremented by one then it is
a modifier bit-field. We also need to account for control
characters. This is wrapped as a single utility called ~maybe-combo~:

#+BEGIN_SRC lisp
  (defun maybe-combo (key num2)
    (alexandria:if-let ((ctrl (and (characterp key) (controlp key))))
      (prog1 ctrl
        (setf (gesture-mods ctrl) (logior (1- num2) +ctrl-mod+)))
      (or (and (= num2 1) key)
          (make-instance 'gesture :key key :mods (1- num2)))))
#+END_SRC

Now is time to define a handful of known sequences (from the ~CSI~
group and from the ~SS3~):

#+BEGIN_SRC lisp
  (define-key-resolver #\[ #\~ (num1 num2)
    (let ((key (case num1
                 (1 :home) (2  :insert) (3    :delete)
                 (4  :end) (5 :page-up) (6 :page-down)
                 (11  :f1) (12 :f2)  (13  :f3) (14  :f4) ; deprecated
                 (15  :f5) (17 :f6)  (18  :f7) (19  :f8)
                 (20  :f9) (21 :f10) (23 :f11) (24 :f12)
                 (25 :f13) (26 :f14) (28 :f15) (29 :f16)
                 (31 :f17) (32 :f18) (33 :f19) (34 :f20))))
      (maybe-combo key num2)))

  (define-key-resolver #\[ #\A (num1 num2) (maybe-combo :key-up    num2))
  (define-key-resolver #\[ #\B (num1 num2) (maybe-combo :key-down  num2))
  (define-key-resolver #\[ #\C (num1 num2) (maybe-combo :key-right num2))
  (define-key-resolver #\[ #\D (num1 num2) (maybe-combo :key-left  num2))

  (define-key-resolver #\O #\P (num1 num2) (maybe-combo :f1 num2))
  (define-key-resolver #\O #\Q (num1 num2) (maybe-combo :f2 num2))
  (define-key-resolver #\O #\R (num1 num2) (maybe-combo :f3 num2))
  (define-key-resolver #\O #\S (num1 num2) (maybe-combo :f4 num2))
#+END_SRC

And, finally, the ~resolve-key~ function which is called by
~escapep~. When the read is incomplete, then it assumes that a
combination ALT+<char>, otherwise it calls the key resolver. If there
is no defined resolver for the sequence we create an unknown gesture
which may be inspected for the actual characters typed.

#+BEGIN_SRC lisp
  (defun resolve-key (group num1 num2 |Hasta la vista, baby|)
    (if (null |Hasta la vista, baby|)
        ;; When there is no terminating character, then it is probably a
        ;; result of pressing ALT+<char>. This is ambiguous, i.e ALT+[
        ;; generates CSI. We try to be as robust as we can here.
        (maybe-combo (case group
                       (#.+escape+ :escape)
                       (#.+delete+ :delete)
                       (t group))
                     (1+ +alt-mod+))
        (funcall (gethash (+ (char-code |Hasta la vista, baby|)
                             (ash (char-code group) 8))
                          ,*key-resolvers*
                          #'(lambda (num1 num2)
                              (let ((k (format nil
                                               "Unknown sequence: ESC ~c ~d ~d ~c"
                                               group num1 num2
                                               |Hasta la vista, baby|)))
                                (make-instance 'gesture :key k :mods 0))))
                 num1 num2)))
#+END_SRC

With that all what is left is the test code, which will print read
characters on the terminal, so we can verify if they are properly
recognized. Notice, that we do not clear whole line, only the reminder
of it after printing the sequence, to avoid unnecessary flicker. Some
key combinations may be intercepted by the window manager.

#+BEGIN_SRC lisp
(let ((characters nil))
  (defun show-screen ()
    (loop for ch = (read-input)
          until (null ch)
          do (push ch characters))
    (setf characters (subseq characters 0 (min 12 (length characters))))
    (set-cursor-position (1+ (random 12))
                         (1+ (random 40)))
    (if (zerop (random 2))
        (put "+")
        (put "-"))
    (with-cursor-position (1 44)
      (loop for row from 1
            for ch in characters
            do (set-cursor-position row 44)
               (format *console-io* (format nil "Read: ~s" ch))
               (clear-line 0)))))
#+END_SRC

You might have noticed, that the ~+alt-mod+~ is defined to be a
parameter. This is to allow mapping the key ALT to META.

#+BEGIN_SRC lisp
  (defun (setf alt-is-meta) (bool)
    (if bool
        (setf +alt-mod+ +meta-mod+)
        (setf +alt-mod+ +alt-mod*+)))
#+END_SRC

* Civilizing the interface

We can do quite a lot already. Our previous demo, despite being pretty
basic, proves that. We want to add some interactive behavior to the
application, so we may assign actions to the key combinations. But
first we'll refactor our abstraction so there are no dangling global
variables around.

We also isolate the low-level terminal access in ~init-console~ and
~close-console~ functions, so we can treat the handler as an opaque
object. We retain the variable ~*console-io*~, but we bind it only in
the console context. We also bind a variable ~*console*~.

#+BEGIN_SRC lisp
  (defun init-console ()
    (prog1 (enable-raw)
      (reset-console)))

  (defun close-console (handler)
    (reset-console)
    (disable-raw handler))

  (defvar *console*)
  (defvar *console-io*)

  (defclass console ()
    ((ios :initarg :ios :accessor ios :documentation "I/O stream for the terminal.")
     (fgc :initarg :fgc :accessor fgc :documentation "Foregorund color.")
     (bgc :initarg :bgc :accessor bgc :documentation "Background color.")
     (pos :initarg :pos :accessor pos :documentation "Cursor position.")
     (cvp :initarg :cvp :accessor cvp :documentation "Cursor visibility.")
     (fps :initarg :fps :accessor fps :documentation "Desired framerate.")
     (app :initarg :app :accessor app :documentation "Application state.")
     (hnd               :accessor hnd :documentation "Terminal handler."))
    (:default-initargs
     :ios (error "I/O stream must be specified.")
     :fgc '(#xff #xa0 #xa0)
     :bgc '(#x00 #x22 #x22)
     :pos '(1 . 1)
     :cvp nil
     :fps 60
     :app nil))

  (defmethod initialize-instance :after ((instance console) &key ios fgc bgc cvp)
    (setf (hnd instance) (init-console))
    (apply #'set-foreground-color fgc)
    (apply #'set-background-color bgc)
    (setf (cursor-visibility) cvp))

  (defmacro with-console ((&rest args
                           &key ios fgc bgc cvp fps &allow-other-keys)
                          &body body)
    (declare (ignore fgc bgc cvp fps))
    `(let* ((*console-io* ,ios)
            (*console* (make-instance 'console ,@args)))
       (unwind-protect (progn ,@body)
         (close-console (hnd *console*)))))

  (defun start-display ()
    (swank:create-server)
    (with-console (:ios *terminal-io*)
      (clear-console)
      (loop (sleep (/ (fps *console*)))
            (show-screen))))
#+END_SRC

To add some interactive behavior we want to assign actions to keys.
We'll define a predicate which decides whether a key matches given
parameters.

#+BEGIN_SRC lisp
(defun keyp (ch key &rest mods)
  (if (null mods)
      (eql ch key)
      (and (typep ch 'gesture)
           (eql (gesture-key ch) key)
           (eql (gesture-mods ch)
                (loop for m in mods
                      summing (ecase m
                                (:c1 +c1-mod+)
                                (:m  +meta-mod+)
                                (:c  +ctrl-mod+)
                                (:a  +alt-mod*+)
                                (:s  +shift-mod+)))))))
#+END_SRC

Now we will add three key combinations:

- C-q :: exit the application
- C-r :: clear the console (i.e to wipe glitches)
- C-u :: call the user function

#+BEGIN_SRC lisp
  (defun show-screen ()
    (loop for ch = (read-input)
          until (null ch)
          do (push ch (app *console*))
             (cond ((keyp ch #\Q :c)
                    (cl-user::quit))
                   ((keyp ch #\R :c)
                    (setf (app *console*) nil)
                    (clear-console))
                   ((keyp ch #\U :c)
                    (ignore-errors (user-action)))))
    (let ((ch (app *console*)))
      (setf (app *console*)
            (subseq ch 0 (min 12 (length ch)))))
    (set-cursor-position (1+ (random 12))
                         (1+ (random 40)))
    (if (zerop (random 2))
        (put "+")
        (put "-"))
    (with-cursor-position (1 44)
      (loop for row from 1
            for ch in (app *console*)
            do (set-cursor-position row 44)
               (format *console-io* (format nil "Read: ~s" ch))
               (clear-line 0))))
#+END_SRC

Notice that, instead of a closure over a variable characters, we use
the slot ~app~ in the ~*console*~ object. Function ~user-action~ may
be defined from REPL – when C-u is pressed it will be executed. It may
be used for instance to change the configuration. We still need to add
appropriate methods which set the console on the configuration change.

#+BEGIN_SRC lisp
  (defmethod (setf fgc) :after (rgb (instance console))
    (apply #'set-foreground-color rgb))

  (defmethod (setf bgc) :after (rgb (instance console))
    (apply #'set-background-color rgb))

  (defmethod (setf pos) :before (pos (instance console))
    (check-type (car pos) (integer 1))
    (check-type (cdr pos) (integer 1)))

  (defmethod (setf pos) :after (pos (instance console))
    (set-cursor-position (car pos) (cdr pos)))

  (defmethod (setf cvp) :after (cvp (instance console))
    (setf (cursor-visibility) (not (null cvp))))

  ;; for example
  (defun user-action ()
    (setf (fgc *console*) (list (random 255) (random 255) (random 255)))
    (setf (bgc *console*) (list (random 255) (random 255) (random 255)))
    (clear-console))
#+END_SRC

We still don't have any means to limit the terminal region for output.
This operation is known as clipping in graphics. We are going to
implement a flexible mechanism based on dynamic variables. For simple
clipping we provide min/max row/col, and for more complex use cases a
custom predicate may be specified. The macro is called ~with-clipping~
and may be nested to achieve intersection of the clipping areas.

The macro ~out~ allows specifying a row, a column, a foreground color
and a background color. It respects clipping limitations by testing
each character. The state of the console is left as it was before
invoking the operator.

#+BEGIN_SRC lisp
  (defvar *row1* '(1))
  (defvar *col1* '(1))
  (defvar *row2* '(24))
  (defvar *col2* '(80))
  (defvar *fun* (list (constantly t)))

  (defmacro with-clipping ((&key fun row1 col1 row2 col2) &body body)
    `(let (,@(when row1 `((*row1* (cons (max (car *row1*) ,row1) *row1*))))
           ,@(when col1 `((*col1* (cons (max (car *col1*) ,col1) *col1*))))
           ,@(when row2 `((*row2* (cons (min (car *row2*) ,row2) *row1*))))
           ,@(when col2 `((*col2* (cons (min (car *col2*) ,col2) *col2*))))
           ,@(when fun  `((*fun*  (cons (let ((old (car *fun*)))
                                          (lambda (row col)
                                            (and (funcall ,fun row col)
                                                 (funcall old row col))))
                                        ,*fun*)))))
       ,@body))

  (defmacro letf (bindings &body body)
    (loop for (place value) in bindings
          for old-val = (gensym)
          collect `(,old-val ,place)      into saves
          collect `(setf ,place ,value)   into store
          collect `(setf ,place ,old-val) into restore
          finally (return `(let (,@saves)
                             (unwind-protect (progn ,@store ,@body)
                               ,@restore)))))

  (defun inside (row col)
    (and (<= (car *row1*) row (car *row2*))
         (<= (car *col1*) col (car *col2*))
         (funcall (car *fun*) row col)))

  (defmacro out ((&key row col fgc bgc) object)
    "Put an object on a console"
    (let ((pos (cond ((and row col) `(cons ,row ,col))
                     (row `(cons ,row (cdr (pos *console*))))
                     (col `(cons (car (pos *console*)) col)))))
      `(let ((str (princ-to-string ,object)))
         (assert (null (find #\newline str)))
         (letf (((pos *console*) (cons (or ,row (car (pos *console*)))
                                       (or ,col (cdr (pos *console*)))))
                ,@(when fgc `(((fgc *console*) ,fgc)))
                ,@(when bgc `(((bgc *console*) ,bgc))))
           (let* ((pos (pos *console*))
                  (row (car pos))
                  (col (cdr pos)))
             (loop for c from col
                   for s across str
                   when (inside row c)
                     do (put s)))))))
#+END_SRC

Another important functionality is a way to clear a specific region.
That and other user-facing control utilities will be available from
the operator ~ctl~.

#+BEGIN_SRC lisp
  (defun clear-rectangle (r1 c1 r2 c2)
    (loop with str = (make-string (1+ (- c2 c1)) :initial-element #\space)
          for r from r1 upto r2
          do (out (:row r :col c1) str)))

  (defmacro ctl (&rest operations)
    `(progn
       ,@(loop for op in operations
               collect (destructuring-bind (name &rest args) op
                         (ecase name
                           (:clr `(clear-rectangle ,@args))
                           (:fgc `(setf (fgc *console*) (list ,@args)))
                           (:bgc `(setf (bgc *console*) (list ,@args)))
                           (:cvp `(setf (cursor-visibility) ,@args))
                           (:pos `(setf (pos *console*) (cons ,(car args)
                                                              ,(cdr args)))))))))
#+END_SRC

Time to use our new tools to implement the show-screen and the user
function:

#+BEGIN_SRC lisp
  (defun show-screen ()
    (loop for ch = (read-input)
          until (null ch)
          do (push ch (app *console*))
             (cond ((keyp ch #\Q :c)
                    (cl-user::quit))
                   ((keyp ch #\R :c)
                    (setf (app *console*) nil)
                    (clear-console))
                   ((keyp ch #\U :c)
                    (ignore-errors (user-action)))))
    (let ((ch (app *console*)))
      (setf (app *console*)
            (subseq ch 0 (min 12 (length ch)))))
    (flet ((ll (row col)
             (or (and (< (abs (- (+ col row) 26)) 2)
                      (<= col 20))
                 (< (abs (- (+ (- 40 col) row) 26)) 2))))
      (with-clipping (:fun #'ll :row1 2 :row2 11)
        (out (:row (1+ (random 12))
              :col (1+ (random 40))
              :bgc `(0 0 0)
              :fgc '(#xbb #x00 #x00))
             (alexandria:random-elt '("X" "O"))))
      (with-clipping (:fun (lambda (row col)
                             (or (= row 1)
                                 (= row 12)
                                 (funcall (complement #'ll) row col))))
        (out (:row (1+ (random 12))
              :col (1+ (random 40))
              :bgc `(0 0 0)
              :fgc (list #x00
                         (alexandria:random-elt '(#x44 #x44 #x44 #x44 #x66))
                         #x44))
             (alexandria:random-elt '("+" "-")))))
    (ctl (:clr 1 44 12 (car *col2*)))
    (loop for row from 1
          for ch in (app *console*)
          do (out (:row row :col 44)
                  (prin1-to-string ch))))

  (defun user-action ()
    (ctl (:fgc (random 255) (random 255) (random 255))
         (:bgc (random 255) (random 255) (random 255))
         (:clr 4 4 10 10)))
#+END_SRC

Clearing the screen part with ~(:clr 1 44 12 (car *col2*))~ may cause
a flicker on terminal emulators with slow refresh rate. For now we
will reduce the FPS, but later we will take another approach to avoid
this problem.

#+BEGIN_SRC lisp
  (defclass console ()
    (#|...|#)
    (:default-initargs
     #|...|#
     :fps 10
     #|...|#))
#+END_SRC

* Determining the terminal dimensions

Time to learn how to determine the terminal size. We already know how
to set a cursor position. Interesting property of this command is that
if we request to set its position beyond the terminal limits, the
cursor will be positioned on a terminal boundary instead. That's how
we are going to determine the terminal size.

#+BEGIN_SRC lisp
  (defun request-cursor-position ()
    (csi 6 "n"))

  (defun user-action ()
    (with-cursor-position (10 3)
      (request-cursor-position)))
#+END_SRC

When we execute the user command by pressing C-u our program will tell
us, that an unknown sequence has been read: ~ESC [ 10 3 R~. Indeed,
that's the sequence which is documented as a result. We will define a
condition to signal, that the cursor-position-report has arrived. When
the sequence is read a condition is signaled and a gesture is returned.

#+BEGIN_SRC lisp
  (define-condition cursor-position-report ()
    ((rows :initarg :row :reader row)
     (cols :initarg :col :reader col)))

  (define-key-resolver #\[ #\R (row col)
    (signal 'cursor-position-report :row row :col col)
    (make-instance 'gesture
                   :key (format nil "Cursor position: ~s ~s" row col)
                   :mods 0))
#+END_SRC

We will use it to print a character on the right-bottom-most cell to
see if it works. An important bit of information is that if we set the
cursor beyond the terminal, it will be positioned over the last cell
instead, so if we request the position back we should receive a total
number of rows and columns of the console.

To do that we'll add slots to a class representing the console and add
a handler-case above read-input which assigns these slots. Moreover we
modify the ~user-action~ to request the cursor position after setting
it to some unreasonably big value. Now when we press C-u the character
should appear on the bottom-right corner of the terminal. Notice, that
we also update the clipping area (*row2* and *col2*). Otherwise our
character could have been filtered.

#+BEGIN_SRC lisp
  (defclass console ()
    (#|...|#
     (rows :accessor rows :initform 24 :documentation "Terminal number of rows.")
     (cols :accessor cols :initform 80 :documentation "Terminal number of cols."))
    #|...|#)

  (defun show-screen ()
    (loop for ch = (handler-case (read-input)
                     (cursor-position-report (c)
                       (let ((row (row c))
                             (col (col c)))
                         (setf *row2* (list row)
                               ,*col2* (list col)
                               (rows *console*) row
                               (cols *console*) col))
                       nil))
          #|...|#)
    #|...|#
    (out (:row (rows *console*)
          :col (cols *console*))
         "×"))

  (defun user-action ()
    (with-cursor-position ((expt 2 16) (expt 2 16))
      (request-cursor-position)))
#+END_SRC

We are left with a few problems:

- old markers don't disappear unless we reset the whole console
- any cursor position request will end up in resizing of the console
- some terminals emit ambiguous sequence ~ESC [ 1 2 R~ for S-F3
- console is not resized automatically when the terminal is resized

For now we will tackle only the issue of resizing the console when the
terminal window is resized. The other three will be addressed in the
last section. When the terminal window is changed the system sends a
signal SIGWINCH. We want to handle it, so we are going to extend our
~raw_mode.c~ program.

#+BEGIN_SRC c
  struct sigaction *enable_sigwinch(void(*catch_function)(int)) {
    struct sigaction *old_action = malloc(sizeof(struct sigaction));
    struct sigaction new_action;
    new_action.sa_handler = catch_function;
    sigemptyset (&new_action.sa_mask);
    new_action.sa_flags = 0;
    sigaction(SIGWINCH, &new_action, old_action);
    return old_action;
  }

  void disable_sigwinch(struct sigaction *old_action) {
    sigaction(SIGWINCH, old_action, NULL);
    free(old_action);
  }
#+END_SRC

And a glue code for Lisp:

#+BEGIN_SRC lisp
  (cffi:defcfun (enable-sigwinch "enable_sigwinch")
      :pointer
    (callback :pointer))

  (cffi:defcfun (disable-sigwinch "disable_sigwinch")
      :void
    (handler :pointer))

  (cffi:defcallback sigwinch :void
      ((signum :int))
    (declare (ignore signum))
    (update-console-dimensions))
#+END_SRC

And functions doing the actual job. ~get-cursor-position~ works
synchronously and ignores all input the cursor-position-report is
signaled. We may now remove the handler-case from the function
~show-screen~. ~update-console-dimensions~ works differently when it
is called in a context of a console and when it is called from the
interrupt handler.

#+BEGIN_SRC lisp
  (defun get-cursor-position ()
    (request-cursor-position)
    (handler-case (loop (read-input))
      (cursor-position-report (c)
        (values (row c) (col c)))))

  (defvar *console-dirty-p* t)

  (defun update-console-dimensions ()
    (if (boundp '*console*)
        (with-cursor-position ((expt 2 16) (expt 2 16))
          (multiple-value-bind (rows cols)
              (get-cursor-position)
            (setf (rows *console*) rows
                  (cols *console*) cols
                  ,*row2* (list rows)
                  ,*col2* (list cols))
            (setf *console-dirty-p* nil)))
        (setf *console-dirty-p* t)))
#+END_SRC

Time to modify init-console and close-console to call our new
functions. Moreover we should query the terminal size when a console
is created.

#+BEGIN_SRC lisp
  (defun init-console ()
    (prog1 (list (enable-raw)
                 (enable-sigwinch (cffi:callback sigwinch)))
      (reset-console)))

  (defun close-console (handler)
    (reset-console)
    (destructuring-bind (termios sigaction) handler
      (disable-sigwinch sigaction)
      (disable-raw termios)))

  (defmethod initialize-instance :after
      ((instance console) &key fgc bgc pos cvp)
    (setf (hnd instance) (init-console))
    (apply #'set-foreground-color fgc)
    (apply #'set-background-color bgc)
    (set-cursor-position (car pos) (cdr pos))
    (setf (cursor-visibility) cvp)
    (let ((*console* instance))
      (update-console-dimensions)))
#+END_SRC

There is still a problem with this code. We call functions writing and
reading from the terminal, and at any time we may receive an interrupt
(which will put us in a debugger). We are going to run the console
loop in a separate thread (add bordeaux-threads to the ASD file now),
so the main thread may be safely interrupted.

#+BEGIN_SRC lisp
  (defmacro with-console ((&rest args
                           &key ios fgc bgc cvp fps &allow-other-keys)
                          &body body)
    (declare (ignore fgc bgc cvp fps))
    `(let ((proc (bt:make-thread
                  (lambda ()
                    (handler-case
                        (let* ((*console-io* ,ios)
                               (*console* (make-instance 'console ,@args)))
                          (unwind-protect (progn ,@body)
                            (close-console (hnd *console*))))
                      (serious-condition (c)
                        (format t "Exit due to~%~a~%" c)
                        (cl-user::quit)))))))
       (bt:join-thread proc)))
#+END_SRC

When the flag ~*console-dirty-p*~ is true, we should update the
terminal dimensions. It is part of the application logic.

#+BEGIN_SRC lisp
  (defun start-display ()
    (swank:create-server)
    (with-console (:ios *terminal-io*)
      (clear-console)
      (loop (sleep (/ (fps *console*)))
            (when *console-dirty-p*
              (update-console-dimensions))
            (show-screen))))
#+END_SRC

Now when we resize the terminal the marker is printed in the
appropriate location right away.

* Adding a mouse tracking support

Terminal emulators which are compatible with xterm allow tracking the
mouse. There are few possible modes (i.e track only mouse clicks, or
track everything, motion included), as well as a few schemes for
reporting the event. We are interested in tracking all events and in
extended report (because the "default" scheme has serious dimension
limitations due to byte encoding).

#+BEGIN_SRC lisp
  ;;; (csi ? tracking ; encoding h/l)
  ;;; tracking: 1000 - normal, 1002 - button, 1003 - all motion
  ;;; encoding: 1006 - sgr encoding scheme
  (defun (setf mouse-tracking) (enabledp)
    (if enabledp
        (csi "?" 1003 ";" 1006 "h")
        (csi "?" 1003 "l")))
#+END_SRC

Each event is reported as ~ESC [ > Cb;Cx;Cy m/M~. Cb encodes pressed
buttons, Cx and Cy are integers put in text for the event column and
row. Until now we were only parsing input sequences which have two
numbers, so it is time to improve the parse-escape-sequence function
to accept any number of semicolon separated integers:

#+BEGIN_SRC lisp
  (defun parse-escape-sequence (&aux char)
    (flet ((read-num ()
             (loop while (and char (digit-char-p char))
                   collecting char into num
                   do (setf char (read-char-no-hang *console-io*))
                   finally (when num
                             (return (parse-integer (coerce num 'string)))))))
      (loop
        do (setf char (read-char-no-hang *console-io*))
        collect (or (read-num) 1) into nums
        until (or (null char)
                  (char/= #\; char))
        finally (return (values nums char)))))

  (defun escapep (ch)
    (unless (char= ch +escape+)
      (return-from escapep nil))
    (alexandria:if-let ((next-ch (read-char-no-hang *console-io*)))
      ;; A keycode: [\[NO](<num>)(;<num>)[~A-Z].
      (multiple-value-bind (nums terminator)
          (parse-escape-sequence)
        (destructuring-bind (&optional (num1 1) (num2 1)) nums
          (resolve-key next-ch num1 num2 terminator)))
      :escape))
#+END_SRC

Mouse state encoded in ~Cb~ works as follows:

- if the sixth bit (32) is "on", it is a motion event
- otherwise terminating character #\M is "press", #\m is "release"
- modifiers are encoded in third to fifth bits (shift, alt, ctrl)
- pressed mouse button is encoded in two first bits, and seventh/eight

This bit twiddling is a good opportunity to use ldb and ash as seen
below:

#+BEGIN_SRC lisp
  (defun resolve-mouse (btn col row |Hasta la vista, baby|)
    (let ((state (cond ((not (zerop (ldb (cons 1 5) btn))) :motion)
                       ((char= #\M |Hasta la vista, baby|) :press)
                       ((char= #\m |Hasta la vista, baby|) :release)))
          (mods (+ (if (zerop (ldb (cons 1 2) btn)) 0 +shift-mod+)
                   (if (zerop (ldb (cons 1 3) btn)) 0 +alt-mod+)
                   (if (zerop (ldb (cons 1 4) btn)) 0 +ctrl-mod+)))
          (key (case (+ (ldb (cons 2 0) btn)
                        (ash (ldb (cons 2 6) btn) 2))
                 (#b0000 :left)
                 (#b0001 :middle)
                 (#b0010 :right)
                 (#b0011 :none)
                 ;; 64
                 (#b0100 :wheel-up)
                 (#b0101 :wheel-down)
                 (#b0110 :wheel-left)
                 (#b0111 :wheel-right)
                 ;; 128 (xterm >= 341)
                 (#b1000 :extra-1)
                 (#b1001 :extra-2)
                 (#b1010 :extra-3)
                 (#b1011 :extra-4))))
      (make-instance 'gesture
                     :key (format nil "row: ~2d col: ~2d [~a ~a] ~a"
                                  row col key btn state)
                     :mods mods)))
#+END_SRC

Now we add handling mouse to the ~escapep~ function and allow enabling
it in ~user-action~:

#+BEGIN_SRC lisp
  (defun escapep (ch)
    (unless (char= ch +escape+)
      (return-from escapep nil))
    (alexandria:if-let ((next-ch (read-char-no-hang *console-io*)))
      ;; A keycode: [\[NO](<num>)(;<num>)[~A-Z].
      ;; SGR mouse: '[' '<' num ';' num ';' num ';' [Mm]
      (if (and (char= #\[ next-ch)
               (char= #\< (peek-char t *console-io* nil #\x))
               (read-char-no-hang *console-io*))
          (multiple-value-bind (nums terminator)
              (parse-escape-sequence)
            (destructuring-bind (num1 num2 num3) nums
              (resolve-mouse num1 num2 num3 terminator)))
          (multiple-value-bind (nums terminator)
              (parse-escape-sequence)
            (destructuring-bind (&optional (num1 1) (num2 1)) nums
              (resolve-key next-ch num1 num2 terminator))))
      :escape))

  (defun user-action ()
    (setf (mouse-tracking) t))
#+END_SRC

When you press C-u now all mouse events should be reported i.e as
~#<"row: 13 col: 95 [LEFT 0] RELEASE" NIL>~. It is noteworthy that
some terminals despite claiming that they are xterm-compatible, may
behave differently. I.e on KDE's Konsole mouse motion is reported only
when any mouse button is pressed.

Finally it is time to integrate the pointer tracking in our ctl
interface and to the console class.

#+BEGIN_SRC lisp
(defmacro ctl (&rest operations)
  #|...|#
  (:ptr `(setf (mouse-tracking) ,@args))
  #|...|#)

(defclass console ()
  (#|...|#
   (ptr :initarg :ptr :accessor ptr :documentation "Pointer tracking.")
   #|...|#)
  (:default-initargs #|...|# :ptr t #|... |#))


(defmethod initialize-instance :after
    ((instance console) &key fgc bgc pos cvp ptr)
  #|...|#
  (setf (mouse-tracking) ptr)
  #|...|#)

(defmethod (setf ptr) :after (ptr (instance console))
  (setf (mouse-tracking) (not (null ptr))))
#+END_SRC

* Extending examples

Let's construct a few examples which will help us identify some
problems. First move functions ~start-display~, ~show-screen~ and
~user-action~ to a separate file ~examples.lisp~ (don't forget to add
this file to the system definition).

First we'll rework slightly our abstraction. First of all we'll
introduce a frame-manager class which will be responsible for
multiplexing input and output on the screen. It has two slots:

- frames :: maintains a list of managed windows
- active :: if this slot has a frame, then only this frame is rendered

All events will be passed to the function handle-event for the
frame-manager to manage. We'll bind few keys initially: C-q will exit
the application and C-r will remove all frames and clear the screen.

#+BEGIN_SRC lisp
  (defclass frame-manager ()
    ((frames :initarg :frames :accessor frames :documentation "All frames.")
     (active :initarg :active :accessor active :documentation "Active frame."))
    (:default-initargs :frames nil :active nil))

  (defun handle-event (fm event)
    (flet ((reset ()
             (setf (frames fm) nil
                   (active fm) nil)
             (clear-console)))
      (cond ((keyp event #\Q :c)
             (cl-user::quit))
            ((keyp event #\R :c)
             (reset)))))

  (defun display-screen (fm)
    (alexandria:if-let ((frame (active fm)))
      (render-frame frame)
      (dolist (frame (frames fm))
        (render-frame frame))))

  (defun render-frame (huh?)
    (declare (ignore huh?))
    (error "niy!"))
#+END_SRC

We will refactor the function ~start-display~ to show a modeline at
the top which displays the current number of rows, columns and the
FPS. Moreover it will create the frame manager and call functions
defined above. When we start the application we'll see a heart warming
message "We are that good!", meaning that we were too fast to measure
the time meanigfully.

#+BEGIN_SRC lisp
  (defun start-display ()
    (swank:create-server)
    (with-console (:ios *terminal-io*)
      (clear-console)
      (loop with rows = (rows *console*)
            with cols = (cols *console*)
            with fm = (make-instance 'frame-manager)
            do (when *console-dirty-p*
                 (update-console-dimensions)
                 (setf rows (rows *console*)
                       cols (cols *console*)))
            do (loop for ch = (read-input)
                     until (null ch)
                     do (handle-event fm ch))
            do (let (start stop delta)
                 (setf start (get-internal-real-time))
                 (display-screen fm)
                 (setf stop (get-internal-real-time))
                 (setf delta (/ (- stop start)
                                internal-time-units-per-second))
                 (ctl (:fgc #x22 #x22 #x22)
                      (:bgc #xbb #xbb #xbb))
                 (let* ((status (format nil "Rows ~3d, Cols ~3d, FPS ~8,2f"
                                        (1- rows) cols (if (zerop delta)
                                                           :|We are that good!|
                                                           (/ 1.0 delta))))
                        (len (length status)))
                   (ctl (:clr 1 (1+ len) 1 cols))
                   (out (:col 1 :row 1) status))
                 (ctl (:fgc #xff #xa0 #xa0)
                      (:bgc #x22 #x22 #x22))))))
#+END_SRC

Now we'll define a frame. A frame will be defined by its clipping
region and the rendering function.

#+BEGIN_SRC lisp
  (defclass frame ()
    ((rfn :initarg :rfn :accessor rfn :documentation "Rendering function.")
     (fsz :initarg :fsz :accessor fsz :documentation "Frame dimensions.")))

  (defun render-frame (frame)
    (destructuring-bind (r1 c1 r2 c2) (fsz frame)
      (with-clipping (:row1 r1 :col1 c1 :row2 r2 :col2 c2)
        (funcall (rfn frame) frame))))
#+END_SRC

To have something useful to render we'll also define three demos:

- colorful noise :: works like a white noise, but in color
- animation :: draws a square bounding with constant speed
- key press reporter :: prints events like previously

We'll use them to illustrate issues with our rendering. Colorful noise
run maximized will be our baseline benchmark (which proves that we are
very inefficient), and when two frames overlap it will clearly show a
flicker. Animation will also show flicker when we clear the background
before drawing the square despite big fps. Also it is a fine example
which illustrates how the animation speed should always be independent
of fps. The last example shows right now that we have no meaningful
way of obtaining input without stealing them from the frame manager
and with small enough frame will illustrate necessity of scrollbars.

#+BEGIN_SRC lisp
  (defun make-noise-frame (r1 c1 r2 c2)
    (flet ((make-noise-renderer (color)
             (lambda (frame)
               (destructuring-bind (r1 c1 r2 c2) (fsz frame)
                 (loop for row from r1 upto r2
                       do (loop for col from c1 upto c2
                                do (out (:row row
                                         :col col
                                         :bgc `(0 0 0)
                                         :fgc color)
                                        (alexandria:random-elt '("+" "-")))))))))
      (make-instance 'frame
                     :rfn (make-noise-renderer
                           (list (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))
                                 (alexandria:random-elt '(#x22 #x88 #xff))))
                     :fsz (list r1 c1 r2 c2))))

  (defun make-animation-frame (r1 c1 r2 c2 speed)
    (let ((last-time (get-internal-real-time))
          (dc 1)
          (current-row (truncate (+ r1 r2) 2))
          (current-col (+ c1 2)))
      (flet ((draw-square ()
               (ctl (:bgc #x44 #x44 #x00)
                    (:fgc #xff #xbb #x00)
                    (:clr r1 c1 r2 c2))
               (let* ((now (get-internal-real-time))
                      (delta (- now last-time))
                      (seconds (/ delta internal-time-units-per-second)))
                 (incf current-col (* seconds speed dc))
                 (setf last-time now))
               (cond ((>= (+ current-col 2) c2)
                      (setf dc -1))
                     ((<= (- current-col 2) c1)
                      (setf dc +1)))
               (setf current-col
                     (alexandria:clamp current-col (+ c1 2) (- c2 2)))
               (loop with row = current-row
                     with col = (round current-col)
                     for r from (1- row) upto (1+ row)
                     do (loop for c from (- col 2) upto (+ col 2)
                              do (out (:row r :col c) "#")))))
        (make-instance 'frame
                       :rfn (lambda (frame)
                              (declare (ignore frame))
                              (draw-square))
                       :fsz (list r1 c1 r2 c2)))))

  (defun make-report-frame (r1 c1 r2 c2)
    (flet ((reporter (frame)
             (out (:row r1 :col c1)
                  "I'd like to report the key, but I don't know how.")))
     (make-instance 'frame
                    :rfn #'reporter
                    :fsz (list r1 c1 r2 c2))))
#+END_SRC

Finally we'd like to see them on the screen, so we'll bind C-n and C-m
for two different scenarios. Also C-u will be bound to toggle the
active frame (which is picked at random). Add the following clauses to
cond in ~handle-event~:

#+BEGIN_SRC lisp
  (defun handle-event (fm event)
    #|...|#
    (cond
      #|...|#
      ((keyp event #\N :c)
       (reset)
       (setf (frames fm)
             (list (make-noise-frame 4  2 12 20)
                   (make-noise-frame 6 12 14 30)
                   (make-animation-frame 4 36 10 78 20)
                   (make-report-frame 20 3 25 15))))
      ((keyp event #\M :c)
       (reset)
       (setf (frames fm)
             (list (make-noise-frame 2
                                     2
                                     (rows *console*)
                                     (cols *console*)))))
      ((keyp event #\U :c)
       (if (active fm)
           (setf (active fm) nil)
           (alexandria:when-let ((frs (frames fm)))
             (setf (active fm) (alexandria:random-elt frs)))))))
#+END_SRC

We want to have window decorations. On a terminal space is limited and
each character is precious, so we'll draw decorations only on the
right border of the frame. Desired behavior is as follows:

- press "x" to close the frame
- press "o" to maximize the frame ("v" to reverse)
- press ">" to minimize the frame ("<" to reverse)
- drag " " to move the frame
- drag "/" to resize the frame
- when frame output exceeds the frame size, add the scroll bars

#+BEGIN_SRC lisp
  (defun render-window (frame)
    (destructuring-bind (wr1 wc1 wr2 wc2) (fsz frame)
      (declare (ignore wc1))
      (ctl (:bgc #x11 #x11 #x11)
           (:fgc #xbb #xbb #xbb))
      (let ((col (1+ wc2)))
        (out (:row wr1 :col col :fgc '(#xff #x22 #x44)) "x")
        (out (:row (+ wr1 1) :col col) "o")
        (out (:row (+ wr1 2) :col col) ">")
        (loop for row from (+ wr1 3) upto wr2
              do (out (:row row :col col) " "))
        (out (:row (- wr2 0) :col col) "/"))
      (ctl (:bgc #x22 #x22 #x22)
           (:fgc #xbb #xbb #xbb))
      (render-frame frame)))

  (defun display-screen (fm)
    (alexandria:if-let ((frame (active fm)))
      (render-window frame)
      (dolist (frame (frames fm))
        (render-window frame))))
#+END_SRC

Now press C-n to see a few frames and press C-m to see our baseline
example. That shoud help us with testing in the next section.

                   for c.g = (alexandria:random-elt '(#x44 #x44 #x44 #x44 #x66))
                   do (out (:row row
                            :col col
                            :bgc `(0 0 0)
                            :fgc (list #x00 c.g #x44))
                           (alexandria:random-elt '("+" "-"))))))

  (defun user-action ()
    #|plops|#)
#+END_SRC

Don't forget to update the system definition:

#+BEGIN_SRC lisp
  (defsystem "eu.turtleware.charming-clim"
    #| ... |#
    :components (#| ... |#
                 (:file "examples")))
#+END_SRC

When we run the example we'll notice, that on 80x24 area we render a
frame with a very the unimpressive speed 14fps. We will rectify that
in the next chapter, right now we will focus on extending examples. We
will allow creating multiple frames with various dimensions.

