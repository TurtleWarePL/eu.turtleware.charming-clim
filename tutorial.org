#+title: Charming CLIM tutorial part 1 – controlling the terminal
#+author: Daniel 'jackdaniel' Kochmański

When building a console backend for McCLIM there are three terminal
capabilities that we need:

- configuring the terminal (raw mode, no echo, querying properties)
- drawing output (positioning cursor and writing with attributes)
- reading events (keyboard, pointer and window status changes)

* Configuring the terminal

To know where the terminal is, we need to start the implementation
from a console and save streams in separate variables, because
typically SWANK rebinds them.

#+BEGIN_SRC common-lisp
(defvar *console-io* *terminal-io*)
(swank:create-server)
(loop (sleep most-positive-fixnum))
#+END_SRC

Most things may be implemented with ANSI escape sequences and various
extensions to them. Unfortunately we can't turn off echo and line
buffering from this level. We will use a minimal C program to do that,
which we will call with FFI.

#+BEGIN_SRC c
  /* This small program is written based on a tutorial found under URL:
     https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html */

  #include <stdlib.h>
  #include <termios.h>
  #include <unistd.h>

  struct termios *enable_raw() {
    struct termios *orig_termios = malloc(sizeof(struct termios));
    struct termios raw;
    tcgetattr(STDIN_FILENO, orig_termios);
    raw = *orig_termios;
    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
    raw.c_oflag &= ~(OPOST);
    raw.c_cflag |= (CS8);
    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
    return orig_termios;
  }

  void disable_raw(struct termios *orig_termios) {
    tcsetattr(STDIN_FILENO, TCSAFLUSH, orig_termios);
    free(orig_termios);
  }
#+END_SRC

And here's how we will use it. Loading the C file will be performed by
ASDF, but you may always compile and load it manually. To allow
interactive recompilation we'll use a function ~show-screen~ which
will be called each second.

#+BEGIN_SRC common-lisp
  (defpackage #:eu.turtleware.charming-clim
    (:use #:cl)
    (:export #:start-display))
  (in-package #:eu.turtleware.charming-clim)

  ;; gcc raw-mode.c -shared -o raw-mode.so
  ;; (cffi:load-foreign-library "/path/to/raw-mode.so")

  (cffi:defcfun (enable-raw "enable_raw")
      :pointer)
  (cffi:defcfun (disable-raw "disable_raw")
      :void
    (handler :pointer))

  (defvar *console-io* *terminal-io*)

  (defmacro with-console (opts &body body)
    (declare (ignore opts))
    (let ((handler (gensym)))
      `(let ((,handler (enable-raw)))
         (unwind-protect (progn ,@body)
           (disable-raw ,handler)))))

  (declaim (notinline show-screen))
  (defun show-screen ()
    (format *console-io* "~acHello World!" #\esc)
    (finish-output *console-io*))

  (defun start-display ()
    (swank:create-server)
    (with-console ()
      (loop (sleep 1)
            (show-screen))))
#+END_SRC

Finally, to wrap things up, we need to define a loadable system. Let's
name the C file "raw-mode.c", and the Lisp file "terminal.lisp". The
directory will have a flat structure with the ASDF definition file
~eu.turtleware.charming-clim.asd~.

I don't like ASDF so I won't focus on details of how and why this
works, it is enough to say that it will work on systems with a C
compiler ~cc~ on appropriate platforms which accept appropriate flags.

#+BEGIN_SRC lisp
  (defpackage #:charming-clim-system
    (:use #:asdf #:cl)
    (:export #:cfile))
  (in-package #:charming-clim-system)

  (defclass cfile (c-source-file) ())

  (defmethod output-files ((o compile-op) (c cfile))
    (list (make-pathname :name (component-name c) :type "so")))

  (defmethod perform ((o compile-op) (c cfile))
    (let ((in  (first (input-files o c)))
          (out (first (output-files o c))))
      (uiop:run-program (format nil "cc -shared ~a -o ~a" in out))))

  (defmethod perform ((o load-op) (c cfile))
    (let ((in (first (input-files o c))))
      (uiop:call-function "cffi:load-foreign-library" in)))

  (defmethod operation-done-p ((o compile-op) (c cfile))
    (let ((in  (first (input-files o c)))
          (out (first (output-files o c))))
      (and (probe-file in)
           (probe-file out)
           (> (file-write-date out) (file-write-date in)))))

  (defsystem "eu.turtleware.charming-clim"
    :defsystem-depends-on (#:cffi)
    :depends-on (#:cffi #:swank)
    :components ((:static-file "tutorial.org")
                 (:cfile "raw-mode")
                 (:file "terminal")))
#+END_SRC

Now it is enough to load a system "eu.turtleware.charming-clim" in a
terminal (not in Emacs!), and call
~(eu.turtleware.charming-clim:start-display)~ to see on a screen a
string "Hello World!". Now connect to the swank server and let the
hacking commence. When you want to get your console back, type
~(quit)~ in the REPL (or call another operator which stops your lisp).

* Escape sequences

We will control the terminal by using escape sequences from the ANSI
ECMA-48 standard with some useful extensions. To understand better how
escape sequences work you may refer to the following:

- wikipedia article :: https://en.wikipedia.org/wiki/ANSI_escape_code
- control sequences :: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html
- standard ecma-48  :: https://www.ecma-international.org/publications/standards/Ecma-048.htm

Escape sequences are often chained and accept parameters. Numbers are
encoded with characters with delimiters. Character case matters. Let's
define three a few utilities.

#+BEGIN_SRC common-lisp
  (defun put (&rest args)
    "Put raw string on a console"
    (format *console-io* "~{~a~}" args)
    (finish-output *console-io*))

  (defun esc (&rest args)
    "Escape sequence"
    (apply #'put #\esc args))

  (defun csi (&rest args)
    "Control sequence introducer"
    (apply #'esc #\[ args))

  (defun sgr (&rest args)
    "Select Graphic Rendition"
    (apply #'csi (append args '("m"))))
#+END_SRC

Time to add a high level interface. These few functions illustrate how
the terminal is controlled. I add more functions when I need them.

#+BEGIN_SRC lisp
  (defun reset-console ()
    "Clears the screen, attributes, cursor position etc."
    (esc "c"))

  (defun clear-console (&optional (mode 2))
    "Erase in display"
    ;; Defined modes:
    ;; 0 - clear from cursor to the end of the display
    ;; 1 - clear from cursor to the start of the display
    ;; 2 - clear entire display
    (csi mode "J"))

  (defun clear-line (&optional (mode 2))
    "Erase in line."
    ;; Defined modes:
    ;; 0 - clear from cursor to the end of the line
    ;; 1 - clear from cursor to the start of the line
    ;; 2 - clear entire line
    (csi mode "K"))

  (defun set-foreground-color (r g b)
    (sgr "38;2;" r ";" g ";" b))

  (defun set-background-color (r g b)
    (sgr "48;2;" r ";" g ";" b))

  (defun save-cursor-position ()
    (send-control (csi "s")))

  (defun restore-cursor-position ()
    (send-control (csi "u")))

  (defun set-cursor-position (row col)
    (cond ((and row col)
           (send-control (csi row ";" col "H")))
          ((not (null n))
           (send-control (csi row ";H")))
          ((not (null m))
           (send-control (csi ";" col "H")))))

  (defmacro with-cursor-position ((row col) &body body)
    `(progn
       (save-cursor-position)
       (set-cursor-position ,row ,col)
       (unwind-protect (progn ,@body)
         (restore-cursor-position))))

  (defun (setf cursor-visibility) (visiblep)
    (if visiblep
        (csi "?" 2 5 "h")
        (csi "?" 2 5 "l")))
#+END_SRC

And finally some more fun function. Typing the following in REPL while
the terminal is open gives the most satisfying result. This example
shows an important property of the terminal: first character is
addressed with a coordinate [1, 1].

#+BEGIN_SRC lisp
  (defparameter *row* 2)
  (defparameter *col* 2)
  (defparameter *dir* 1)
  (reset-console)
  (setf (cursor-visibility) nil)
  (set-background-color #x00 #x22 #x22)
  (set-foreground-color #xff #xa0 #xa0)

  (declaim (notinline show-screen))
  (defun show-screen ()
    (clear-console)
    (let ((str "Hello World!"))
      (set-cursor-position *row* (incf *col* *dir*))
      (cond ((>= (+ (1- *col*) (length str)) 80)
             (setf *dir* -1))
            ((<= *col* 2)
             (setf *dir* +1)))

      (with-cursor-position (*row*  1) (put "|"))
      (with-cursor-position (*row* 81) (put "|"))
      (put str)))
#+END_SRC

Putting aside ~show-screen~ fun we'll improve the loop in
~start-display~ so it is possible to modify the configuration easily.

#+BEGIN_SRC lisp
  (defun show-screen ()
    (set-cursor-position (1+ (random 24))
                         (1+ (random 80)))
    (if (zerop (random 2))
        (put "+")
        (put "-")))

  (defparameter *conf*
    (list :sleep 1/60
          :cursorp nil
          :foreground '(#xff #xa0 #xa0)
          :background '(#x00 #x22 #x22)))

  (defun start-display ()
    (swank:create-server)
    (with-console ()
      (loop with conf
            with seconds
            do (unless (equalp conf *conf*)
                 (setf conf (copy-list *conf*))
                 (destructuring-bind (&key sleep cursorp foreground background)
                     conf
                   (setf seconds sleep)
                   (reset-console)
                   (setf (cursor-visibility) (getf conf :cursorp))
                   (apply #'set-background-color background)
                   (apply #'set-foreground-color foreground)
                   (clear-console)))
               (sleep seconds)
               (show-screen))))
#+END_SRC

* Reading input

We've configured the terminal to accept data in a raw mode. Despite
that we can only read translated sequences, there is no portable way
to access raw keycode press and release events. That is unfortunate.

There are two characters which have a special meaning. ~ESC~ starts
escape sequence and ~DEL~ is not a graphical character despite not
being a control characters. That's why we will signify their
uniqueness by defining appropriate constants.

#+BEGIN_SRC lisp
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defconstant +delete+ (code-char #x7f)
      "The DEL character (#\Rubout), last in the ASCII table.")
    (defconstant +escape+ (code-char #x1b)
      "The ESC character (#\esc)."))
#+END_SRC

From the parsing perspective when we read the input we may encounter
on of the following situations:

- no characters are available
- character is a graphic character (may span few bytes)
- ESC starts the escape sequence which needs to be parsed
- DEL character is read
- character is a control character (needs to be parsed)

#+BEGIN_SRC lisp
  (defun read-input (&aux (ch (read-char-no-hang *console-io*)))
    ;; READ-CHAR may read more than one byte and return an alphanumeric
    ;; character. That's fine because we will return it as-is then.
    (cond ((or (null ch) (graphic-char-p ch))
           (return-from read-input ch))
          ((deletep ch))
          ((escapep ch))
          ((controlp ch))
          (t (error "Unknown input sequence, char code 0x~x~%." (char-code ch)))))
#+END_SRC

We will use ~read-char-no-hang~ to avoid blocking. ~read-input~ will
return either NIL (for now available input), a graphical character, a
keyword for known keys which are not graphical, or a gesture object if
there are modifiers present (or a non-graphical character appears
which has no known keyword representation).

#+BEGIN_SRC lisp
  (defclass gesture ()
    ((key  :initarg :key  :accessor gesture-key)
     (mods :initarg :mods :accessor gesture-mods)))

  (defmethod print-object ((o gesture) s)
    (print-unreadable-object (o s :type nil :identity nil)
      (let ((key (gesture-key o))
            (mods (gesture-mods o)))
        (format s "~s ~s"
                key
                (loop for p in (list +c1-mod+
                                     +meta-mod+
                                     +ctrl-mod+
                                     +alt-mod+
                                     +shift-mod+)
                      for k in '(:C1 :Meta :Ctrl :Alt :Shift)
                      unless (zerop (logand mods p))
                        collect k)))))
#+END_SRC

We may encounter four types of input: control characters (from C0 and
C1 group), escape sequences, delete character and other alphanumerical
characters. Control sequence and other modifiers like Alt must be
encoded, so we will define a simple class representing a gesture.
Character which is read from the terminal will be always either a
character, a keyword or a gesture (or null when there's no input).

#+BEGIN_SRC lisp
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defconstant  +c1-mod+   16)
    (defconstant  +meta-mod+  8)
    (defconstant  +ctrl-mod+  4)
    (defparameter +alt-mod+   2)
    (defconstant  +alt-mod*+  2)
    (defconstant  +shift-mod+ 1))

  (defclass gesture ()
    ((key  :initarg :key  :accessor gesture-key)
     (mods :initarg :mods :accessor gesture-mods)))

  (defmethod print-object ((o gesture) s)
    (print-unreadable-object (o s :type nil :identity nil)
      (let ((key (gesture-key o))
            (mods (gesture-mods o)))
        (format s "~s ~s"
                key
                (loop for p in (list +c1-mod+
                                     +meta-mod+
                                     +ctrl-mod+
                                     +alt-mod*+
                                     +shift-mod+)
                      for k in '(:C1 :Meta :Ctrl :Alt :Shift)
                      unless (zerop (logand mods p))
                        collect k)))))
#+END_SRC

~deletep~ and ~controlp~ are easy. In case of a control we return a
canonical form with a modifier and the character from the third column
of the ASCII table ~[@A-Z\[\\]^_]~. It is worth noting, that controls
from C1 group are not ASCII characters.

#+BEGIN_SRC lisp
(defun control-char-p (ch &aux (code (char-code ch)))
  (or (<= 0 code 31)
      (<= 128 code 159)))

(defun controlp (ch &aux (code (char-code ch)))
  "Predicate determining if the character is a control character.
Returns a generalized boolean (when true returns a gesture)."
  (cond ((<= 0 code 31)
         (make-instance 'gesture
                        :mods +ctrl-mod+
                        :key (code-char (+ code 64))))
        ((<= 128 code 159)
         (make-instance 'gesture
                        :mods +c1-mod+
                        :key (code-char (- code 64))))))

(defun deletep (ch)
  (when (char= ch +delete+)
    :delete))
#+END_SRC

Parsing escape sequences requires little more code. Exact sequences
for keys vary between terminal emulators. On top of that some are
ambigous. We are going to focus on the most widespread ones defined by
xterm which should be compatible with most emulators. When the escape
character is read and there is no futher input, we return ~:escape~.
Otherwise we try to parse the sequence.

#+BEGIN_SRC lisp
  (defun escapep (ch)
    (unless (char= ch +escape+)
      (return-from escapep nil))
    (alexandria:if-let ((next-ch (read-char-no-hang *console-io*)))
      ;; The escape sequence grammar: [\[NO](<num>)(;<num>)[~A-Z].
      (multiple-value-bind (num1 num2 terminator)
          (parse-escape-sequence)
        (resolve-key next-ch num1 num2 terminator))
      :escape))
#+END_SRC

When we parse the escape sequence there are few possibilities. For
instance ~ESC [~ is known as ~Control Sequence Introducer~, some
terminals produce ~ESC <char>~ when we press Alt+<char> etc. Here is
the approach we are going to take:

- if we read ~ESC <char>~ with no further input, assume Alt+<char>
- if we read ~ESC <char>~ and there is further input we try to parse
  the sequence with two optional numbers and a terminating character
- we try to resolve the character by comparing with known sequences

Function ~parse-escape-sequence~ tries to read the sequence with two
numbers defaulting to one and returns ~(values num1 num2 char)~. If
there is nothing to read, the last value is NIL. Escape sequence looks
like this: ~ESC GROUP-CHAR (NUM1) (';' NUM2) TERMINATING-CHAR~.

#+BEGIN_SRC lisp
  (defun parse-escape-sequence ()
    (let ((char (read-char-no-hang *console-io*))
          (num1 1)
          (num2 1))
      (flet ((read-num ()
               (loop while (and char (digit-char-p char))
                     collecting char into num
                     do (setf char (read-char-no-hang *console-io*))
                     finally (when num
                               (return (parse-integer (coerce num 'string)))))))
        (setf num1 (or (read-num) 1))
        (when (null char)
          (return-from parse-escape-sequence (values num1 num2 char)))
        (when (char= char #\;)
          (setf char (read-char-no-hang *console-io*)
                num2 (or (read-num) 1)))
        (values num1 num2 char))))
#+END_SRC

We want to be able to define new escape sequences when needed, so we
will create a small macro responsible for registering new
sequences. It will dispatch to the appropriate parser based on the
group and the terminator character. The function accepts two numeric
arguments.

#+BEGIN_SRC lisp
  (defvar *key-resolvers* (make-hash-table))

  (defmacro define-key-resolver (group terminator (num1 num2) &body body)
    `(setf (gethash ,(+ (char-code terminator)
                        (ash (char-code group) 8))
                    ,*key-resolvers*)
           (lambda (,num1 ,num2)
             (declare (ignorable ,num1 ,num2))
             ,@body)))
#+END_SRC

Some escape sequences are used to encode keys. In that case the second
number represents modifiers. When it is decremented by one then it is
a modifier bit-field. We also need to account for control
characters. This is wrapped as a single utility called ~maybe-combo~:

#+BEGIN_SRC lisp
  (defun maybe-combo (key num2)
    (alexandria:if-let ((ctrl (and (characterp key) (controlp key))))
      (prog1 ctrl
        (setf (gesture-mods ctrl) (logior (1- num2) +ctrl-mod+)))
      (or (and (= num2 1) key)
          (make-instance 'gesture :key key :mods (1- num2)))))
#+END_SRC

Now is time to define a handful of known sequences (from the ~CSI~
group and from the ~SS3~):

#+BEGIN_SRC lisp
  (define-key-resolver #\[ #\~ (num1 num2)
    (let ((key (case num1
                 (1 :home) (2  :insert) (3    :delete)
                 (4  :end) (5 :page-up) (6 :page-down)
                 (11  :f1) (12 :f2)  (13  :f3) (14  :f4) ; deprecated
                 (15  :f5) (17 :f6)  (18  :f7) (19  :f8)
                 (20  :f9) (21 :f10) (23 :f11) (24 :f12)
                 (25 :f13) (26 :f14) (28 :f15) (29 :f16)
                 (31 :f17) (32 :f18) (33 :f19) (34 :f20))))
      (maybe-combo key num2)))

  (define-key-resolver #\[ #\A (num1 num2) (maybe-combo :key-up    num2))
  (define-key-resolver #\[ #\B (num1 num2) (maybe-combo :key-down  num2))
  (define-key-resolver #\[ #\C (num1 num2) (maybe-combo :key-right num2))
  (define-key-resolver #\[ #\D (num1 num2) (maybe-combo :key-left  num2))

  (define-key-resolver #\O #\P (num1 num2) (maybe-combo :f1 num2))
  (define-key-resolver #\O #\Q (num1 num2) (maybe-combo :f2 num2))
  (define-key-resolver #\O #\R (num1 num2) (maybe-combo :f3 num2))
  (define-key-resolver #\O #\S (num1 num2) (maybe-combo :f4 num2))
#+END_SRC

And, finally, the ~resolve-key~ function which is called by
~escapep~. When the read is incomplete, then it assumes that a
combination ALT+<char>, otherwise it calls the key resolver. If there
is no defined resolved for the sequence we create an unknown gesture
which may be inspected for the actual characters typed.

#+BEGIN_SRC lisp
  (defun resolve-key (group num1 num2 |Hasta la vista, baby|)
    (if (null |Hasta la vista, baby|)
        ;; When there is no terminating character, then it is probably a
        ;; result of pressing ALT+<char>. This is ambigous, i.e ALT+[
        ;; generates CSI. We try to be as robust as we can here.
        (maybe-combo (case group
                       (#.+escape+ :escape)
                       (#.+delete+ :delete)
                       (t group))
                     (1+ +alt-mod+))
        (funcall (gethash (+ (char-code |Hasta la vista, baby|)
                             (ash (char-code group) 8))
                          ,*key-resolvers*
                          #'(lambda (num1 num2)
                              (let ((k (format nil
                                               "Unknown sequence: ESC ~c ~d ~d ~c"
                                               group num1 num2
                                               |Hasta la vista, baby|)))
                                (make-instance 'gesture :key k :mods 0))))
                 num1 num2)))
#+END_SRC

With that all what is left is the test code, which will print read
characters on the terminal, so we can verify if they are properly
recognized. Notice, that we do not clear whole line, only the reminder
of it after printing the sequence, to avoid an unnecessary
flicker. Note, that some key combinations may be intercepted by the
window manager.

#+BEGIN_SRC lisp
(let ((characters nil))
  (defun show-screen ()
    (loop for ch = (read-input)
          until (null ch)
          do (push ch characters))
    (setf characters (subseq characters 0 (min 12 (length characters))))
    (set-cursor-position (1+ (random 12))
                         (1+ (random 40)))
    (if (zerop (random 2))
        (put "+")
        (put "-"))
    (with-cursor-position (1 44)
      (loop for row from 1
            for ch in characters
            do (set-cursor-position row 44)
               (format *console-io* (format nil "Read: ~s" ch))
               (clear-line 0)))))
#+END_SRC

You might have noticed, that the ~+alt-mod+~ is defined to be a
parameter. This is to allow mapping the key ALT to META.

#+BEGIN_SRC lisp
  (defun (setf alt-is-meta) (bool)
    (if bool
        (setf +alt-mod+ +meta-mod+)
        (setf +alt-mod+ +alt-mod*+)))
#+END_SRC
