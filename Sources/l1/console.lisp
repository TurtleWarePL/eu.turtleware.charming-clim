(in-package #:eu.turtleware.charming-clim)

(defvar *console*)

(defmacro with-console ((&rest args
                         &key
                           ios fgc bgc cvp fps
                           (console-class ''console)
                         &allow-other-keys)
                        &body body)
  (declare (ignore fgc bgc cvp fps))
  (remf args :console-class)
  `(let* ((*terminal* ,ios)
          (*console* (make-instance ,console-class ,@args)))
     (unwind-protect (with-buffer (*console*) ,@body)
       (close-terminal (hnd *console*)))))

(defclass console (buffer)
  ((ios :initarg :ios :accessor ios :documentation "Console I/O stream")
   (cur :initarg :cur :accessor cur :documentation "Drawing cursor")
   (ptr :initarg :ptr :accessor ptr :documentation "Pointer tracking")
   (fps :initarg :fps :accessor fps :documentation "Desired framerate")
   (hnd               :accessor hnd :documentation "Terminal handler"))
  (:default-initargs :ios (error "I/O stream must be specified.")
                     :fgc #xffa0a000
                     :bgc #x22222200
                     :row 1 :col 1
                     :ptr t :fps 10 :cvp nil))

(defmethod initialize-instance :after
    ((instance console) &rest args &key fgc bgc row col cvp ptr)
  (setf (hnd instance) (init-terminal))
  (set-mouse-tracking ptr)
  (setf (cur instance)
        (make-instance 'cursor :fgc fgc :bgc bgc :row row :col col :cvp cvp))
  (let ((*console* instance))
    (process-available-events t)))

(defmethod (setf ptr) :after (ptr (instance console))
  (set-mouse-tracking mouse-tracking (not (null ptr))))

(defmethod flush-buffer ((buffer console) &rest args &key force)
  (declare (ignore args))
  (let* ((cursor (cur buffer))
         (last-fg (fgc cursor))
         (last-bg (bgc cursor))
         (gap 0))
    (set-cursor-position 1 1)
    (iterate-cells (cell crow ccol wrap-p)
        (buffer 1 1 (make-array (* (cols buffer)
                                   (rows buffer))
                                :displaced-to (data buffer)))
      (when wrap-p
        (set-cursor-position crow ccol)
        (setf gap 0))
      (if (and cell (or force (dirty-p cell)))
          (let ((ch (ch cell))
                (fg (fg cell))
                (bg (bg cell)))
            (unless (= fg last-fg)
              (set-foreground-color fg)
              (setf last-fg fg))
            (unless (= bg last-bg)
              (set-background-color bg)
              (setf last-bg bg))
            (when (plusp gap)
              (cursor-right gap)
              (setf gap 0))
            (put ch)
            (setf (dirty-p cell) nil))
          (if force
              (put #\space)
              (incf gap))))
    (set-cursor-position (row cursor) (col cursor))
    (set-foreground-color (fgc cursor))
    (set-background-color (bgc cursor)))
  (finish-output *terminal*))

(defmethod put-cell ((buf console) row col str fgc bgc)
  (let ((cur (cur buf))
        (row (or row (row buf)))
        (col (or col (col buf)))
        (fgc (or fgc (fgc buf)))
        (bgc (or bgc (bgc buf))))
    (setf (cursor-position cur) (values row col))
    (setf (cursor-colors   cur) (values fgc bgc))
    (multiple-value-bind (final-row final-col)
        (iterate-cells (ch crow ccol wrap-p)
            (buf row col (string str))
          (when wrap-p
            (setf (cursor-position cur) (values crow ccol)))
          (if (inside-p buf crow ccol)
              (put ch)
              (cursor-right)))
      (update-cursor-position cur final-row final-col))))

(defmethod handle-event ((client console) (event terminal-resize-event))
  (let ((rows (rows event))
        (cols (cols event)))
    (setf (rows client) rows)
    (setf (cols client) cols)
    (setf (r2 (clip client)) rows)
    (setf (c2 (clip client)) cols)
    (adjust-array (data client)
                  (list rows cols)
                  :initial-element nil)))

(defmethod handle-event ((client console) (event keyboard-event))
  (cond ((keyp event #\Q :c)
         (cl-user::quit))
        ((keyp event #\R :c)
         (process-available-events t)
         (clear-terminal)
         (ctl (:bgc #x22222200)
              (:clr 1 1 (rows *console*) (cols *console*))))))
