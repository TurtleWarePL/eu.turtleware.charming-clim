(in-package #:eu.turtleware.charming-clim)

(defclass vconsole (vbuffer)
  ((ios :initarg :ios :accessor ios :documentation "Console I/O stream.")
   (cvp :initarg :cvp :accessor cvp :documentation "Cursor visibility.")
   (ptr :initarg :ptr :accessor ptr :documentation "Pointer tracking.")
   (fps :initarg :fps :accessor fps :documentation "Desired framerate.")
   (hnd               :accessor hnd :documentation "Terminal handler."))
  (:default-initargs :ios (error "I/O stream must be specified.")
                     :cvp nil
                     :ptr t
                     :fps 10))

(defvar *console*)
(defmacro with-console ((&rest args
                         &key ios fgc bgc cvp fps &allow-other-keys)
                        &body body)
  (declare (ignore fgc bgc cvp fps))
  `(let* ((*console-io* ,ios)
          (*console* (make-instance 'vconsole ,@args)))
     (unwind-protect (with-buffer (*console*) ,@body)
       (close-console (hnd *console*)))))

(defun get-cursor-position ()
  (request-cursor-position)
  (finish-output *console-io*)
  (handler-case (loop (read-input))
    (cursor-position-report (c)
      (values (row c) (col c)))))

(defun update-console-dimensions ()
  (with-cursor-position ((expt 2 16) (expt 2 16))
    (multiple-value-bind (rows cols)
        (get-cursor-position)
      (let* ((console *console*)
             (clip (clip console)))
        (when (and (= (rows console) rows)
                   (= (cols console) cols))
          (return-from update-console-dimensions nil))
        (setf (rows console) rows)
        (setf (cols console) cols)
        (destructuring-bind (ar ac) (array-dimensions (data console))
          (when (or (/= rows ar) (/= cols ac))
            (when (or (> rows ar) (> cols ac))
              (adjust-array (data console)
                            (list rows cols)
                            :initial-element nil))
            (with-buffer (console)
              (ctl (:ffb)))))
        (setf (r2 clip) rows)
        (setf (c2 clip) cols))))
  t)

(defmethod initialize-instance :after
    ((instance vconsole) &key fgc bgc row col cvp ptr)
  (setf (hnd instance) (init-console))
  (set-foreground-color fgc)
  (set-background-color bgc)
  (set-cursor-position row col)
  (set-cursor-visibility cvp)
  (set-mouse-tracking ptr)
  (setf (data instance) (make-array (list 0 0) :adjustable t))
  (setf (rows instance) 0)
  (setf (cols instance) 0)
  (let ((*console* instance))
    (update-console-dimensions)))

(defmethod put-cell ((buf vconsole) row col)
  (let* ((cell (get-cell buf row col))
         (ch (ch cell))
         (bg (bg cell))
         (fg (fg cell)))
    (unless (eql (fgc buf) fg)
      (set-foreground-color fg)
      (setf (fgc buf) fg))
    (unless (eql (bgc buf) bg)
      (set-background-color bg)
      (setf (bgc buf) bg))
    (put ch)
    (setf (dirty-p cell) nil)))

(defmethod flush-buffer ((buf vconsole)
                         &key
                           (r1 1)
                           (c1 1)
                           (r2 (rows buf))
                           (c2 (cols buf))
                           (force nil))
  (loop with skipped = t
        with max-row = (min r2 (rows buf))
        with max-col = (min c2 (cols buf))
        with fgc = (fgc *console*)
        with bgc = (bgc *console*)
        for row from r1 upto max-row
        do (loop for col from c1 upto max-col
                 if (or force (dirty-p (get-cell buf row col)))
                   do (when skipped
                        (set-cursor-position row col)
                        (setf skipped nil))
                      (put-cell buf row col)
                 else
                   do (setf skipped t))
        finally (finish-output *console-io*)
                (unless (eql (fgc buf) fgc)
                  (set-foreground-color fgc)
                  (setf (fgc buf) fgc))
                (unless (eql (bgc buf) bgc)
                  (set-background-color bgc)
                  (setf (bgc buf) bgc))))
